[ { "title": "堆", "url": "/posts/%E6%A0%B9%E5%A0%86/", "categories": "算法", "tags": "堆", "date": "2023-10-07 02:34:00 +0000", "snippet": "堆🟧概述🔻含义： 堆是通过数组化二叉树 同时通过构建堆和重建堆 来实现获取最大值和最小值的数据结构🔻试用场景： 查找最大值和最小值、排序、频率、topK问题🔻时间复杂度： O(nlogN)🔻空间复杂度： O(1)🔻注意事项：🔸是使用大根堆还是小根堆🟧模板 📌优先队列class Solution { public int heap(int[] nums) { //默认小根堆 ...", "content": "堆🟧概述🔻含义： 堆是通过数组化二叉树 同时通过构建堆和重建堆 来实现获取最大值和最小值的数据结构🔻试用场景： 查找最大值和最小值、排序、频率、topK问题🔻时间复杂度： O(nlogN)🔻空间复杂度： O(1)🔻注意事项：🔸是使用大根堆还是小根堆🟧模板 📌优先队列class Solution { public int heap(int[] nums) { //默认小根堆 PriorityQueue&lt;Integer&gt; minHeap =new PriorityQueue&lt;&gt;((a,b)-&gt;(int)(a-b)); //大根堆 PriorityQueue&lt;Integer&gt; maxHeap =new PriorityQueue&lt;&gt;((a,b)-&gt;(int)(b-a)); }} 📌原生写法class Solution { //堆排序 public int[] sortArray(int[] nums) { heapSort(nums); return nums; } public void heapSort(int[] nums) { int len = nums.length-1; buildHeap(nums,len); for(int i=len;i&gt;=1;--i){ swap(nums,i,0); --len; reBuildHeap(nums,len,0); } } public void buildHeap(int[] nums,int len) { for(int i=len/2;i&gt;=0;--i){ reBuildHeap(nums,len,i); } } public void reBuildHeap(int[] nums,int len,int i) { for(;((i&lt;&lt;1)+1)&lt;=len;){ int l=(i&lt;&lt;1)+1; int r=(i&lt;&lt;1)+2; int big=0; if(l&lt;=len&amp;&amp;nums[l]&gt;=nums[i]){ big = l; }else{ big = i; } if(r&lt;=len&amp;&amp;nums[r]&gt;=nums[big]){ big = r; } if(i!=big){ swap(nums,i,big); i=big; }else{ break; } } } void swap(int[]nums,int l,int r){ int t = nums[l]; nums[l]=nums[r]; nums[r]=t; }}🟧总结🔻总结1:堆的各项复杂度指标🔸时间复杂度:O(nlogN)🔸空间复杂度:O(1)🔻总结2:堆使用场景🔸排序、topK等🟧思考🔻思考1:堆的为何使用数组化二叉树存储数据?🔸🟧泛化🔻泛化1:从堆使用数组化二叉树存储数据能得到什么启发?🔸" }, { "title": "滑动窗口", "url": "/posts/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/", "categories": "算法", "tags": "多指针", "date": "2023-10-07 02:34:00 +0000", "snippet": "滑动窗口🟧概述🔻含义： 使用一个零时变量记录过程值 当这个过程值满足题目要求时候 就收敛窗口直到过程值不满足题目要求 否则一直扩大窗口统计值🔻试用场景： 查找连续正数数组或字符串以及子数组、子串问题🔻时间复杂度： O(n²)-&gt;O(n)🔻空间复杂度： O(n)🔻注意事项：🔸满足滑动窗口的单调性🔸过程变量的选择(数组、普通变量、容器) 收敛扩大窗口的时机(题意)🔸收敛窗口的移动(++l)...", "content": "滑动窗口🟧概述🔻含义： 使用一个零时变量记录过程值 当这个过程值满足题目要求时候 就收敛窗口直到过程值不满足题目要求 否则一直扩大窗口统计值🔻试用场景： 查找连续正数数组或字符串以及子数组、子串问题🔻时间复杂度： O(n²)-&gt;O(n)🔻空间复杂度： O(n)🔻注意事项：🔸满足滑动窗口的单调性🔸过程变量的选择(数组、普通变量、容器) 收敛扩大窗口的时机(题意)🔸收敛窗口的移动(++l)🔸收敛窗口的条件(LIMIT)🔸答案是最大值还是最小值(题意)🔸统计答案的位置(个数还是长度)🟧模板 📌通用模板class Solution { public int Window(int[] nums) { int limit=???; int len = nums.length; int temp=0;/int[]temp= new int[128];/Map temp= new HashMap(); int res=0; int l=0; int r=0; while(r&lt;len){ //限定条件下对temp进行增益; ++temp; // temp+=nums[r]; //满足题目要求 就收敛窗口 temp和limit(根据题目意思来)的相对关系 while(temp???limit){ //内部循环的值 和前面的值 以及给定的limit相关 //限定条件下对temp进行减益; --temp; ++l; } //结果统计返回 int curLen = r-l+1; res = Math.min/max(res,curLen); res+=r-l+1; ++r; } return res; }}🟧总结🔻思考1:为什么滑动窗口能避免暴力搜索?🔸总的来说两个循环之间没有直接的关系 暴力的嵌套循环，维护了一个窗口，但是它窗口需要外层循环指定窗口起始位置内层循环遍历窗口元素，并计算窗口所求值而滑动窗口的窗口，可以通过前一个窗口弃掉第一值，加入后一个新值得到，通过前一个窗口得到后一个窗口，利用这种关联关系避免嵌套循环🔻思考2:滑动窗口本质?🔸滑动窗口本质上来源于单调性，一般可以理解为，随着左端点位置的增加，其最优决策的右端点位置单调不减 利用决策单调性来实现复杂度优化🔸破坏 右端点单调性的条件都会导致 滑动窗口不适用 比如 数组中的数有负数等·····🔻思考3:滑动窗口实际应用?🔸TCP的流量控制：维护一个发送窗口 窗口不断扩大达到最大窗口长度就不再扩大 当收到一个ack就缩小窗口 此过程是动态的🔻思考4:滑动窗口的限制条件?🔸理清楚 limit的含义 边界是什么🔻思考5:滑动窗口什么时候扩大?🔸temp累计结果 始终不满足 limit 就扩大🔻思考6:滑动窗口什么时候缩小?🔸temp累计结果 始终满足 limit 就缩小🔻思考7:统计答案?🔸什么位置统计答案? 外while 还是内while🔸统计答案的方式? 求最大值/最小值/统计个数" }, { "title": "回溯", "url": "/posts/%E5%9B%9E%E6%BA%AF/", "categories": "算法", "tags": "回溯", "date": "2023-10-07 02:34:00 +0000", "snippet": "回溯🟧概述🔻含义： 回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就 回溯 返回，尝试别的路径🔻试用场景： 排列组合、优化穷举等🔻时间复杂度： 具体问题具体分析🔻空间复杂度： 递归枚举需要用到栈🔻注意事项：🔸单个path回溯完毕后要删除上一次回溯的节点:path.remove(path.size()-1);🔸结果集收集的条件:if(终...", "content": "回溯🟧概述🔻含义： 回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就 回溯 返回，尝试别的路径🔻试用场景： 排列组合、优化穷举等🔻时间复杂度： 具体问题具体分析🔻空间复杂度： 递归枚举需要用到栈🔻注意事项：🔸单个path回溯完毕后要删除上一次回溯的节点:path.remove(path.size()-1);🔸结果集收集的条件:if(终止条件) res.add(new ArrayList(path));🔸去重的条件:if(去重条件) continue;🔸每个组合中的值用是否能重复使用 -&gt; 下一次回溯的起点idx🔸去重的条件和方式🔸每个组合中的值用是否能重复使用：不能重复用:handle(s,i+1);能重复:handle(s,i);🔸解集不能包含重复的组合：Arrays.sort(nums);➕if(i&gt;idx&amp;&amp;nums[i]==nums[i-1]&amp;&amp;!vis[i-1]||vis[i])continue;🔸下一次回溯的起点idx：一般是和题目和能否重复使用相关 不能重复用:handle(s,i+1);能重复:handle(s,i);🟧模板 📌通用模板class Solution { List&lt;List&lt;Integer&gt;&gt; res =new ArrayList(); List&lt;Integer&gt; path = new ArrayList(); int[]/Set/Map visted;//去重变量 public List&lt;List&lt;Integer&gt;&gt; Question(int[]nums) { backTrace(nums); return res; } void backTrace(int[]nums,int idx){ if(终止条件) res.add(new ArrayList(path)); if(去重条件) continue; for(int i=idx;i&lt;nums.length;++i){ path.add(nums[i]); handle(nums,i); path.remove(path.size()-1); } }}🟧总结🔻思考1:为什么使用回溯?🔸回溯中采用剪枝的方式去优化暴力枚举降低时间复杂度🔻思考2:本质?🔸采用剪枝和其他去重变量做选择式枚举🔸基于深度优先搜索和约束函数的问题求解方法🔻思考3:实际应用?🔸排列组合问题🔻思考4:限制条件?🔸剪枝方案和题目的数量大小决定复杂度🔻思考5:对比穷举法?🔸回溯法与穷举法有某些联系，它们都是基于试探的。🔸穷举法:要将一个解的各个部分全部生成后，才检查是否满足条件，若不满足，则直接放弃该完整解，然后再尝试另一个可能的完整解，它并没有沿着一个可能的完整解的各个部分逐步回退生成解的过程。🔸回溯法:一个解的各个部分是逐步生成的，当发现当前生成的某部分不满足约束条件时，就放弃该步所做的工作，退到上一步进行新的尝试，而不是放弃整个解重来。" }, { "title": "原地哈希", "url": "/posts/%E5%8E%9F%E5%9C%B0%E5%93%88%E5%B8%8C/", "categories": "算法", "tags": "原地哈希", "date": "2023-10-07 02:34:00 +0000", "snippet": "原地哈希🟧概述🔻含义： 数组当作哈希表 通过不同场景(重复整数、缺少整数)选择标记方式(交换或者标记为负数) 判断某个值/几个值 存不存在🔻试用场景： 数组的所有数字都是从0开始或者1开始(正数) 并且对空间复杂度要求为O(1)🔻时间复杂度： O(n)🔻空间复杂度： O(n)🔻注意事项：🔸数字必须为正数🔸不能破坏单调性🟧模板📌通用模板public class Temple{ publi...", "content": "原地哈希🟧概述🔻含义： 数组当作哈希表 通过不同场景(重复整数、缺少整数)选择标记方式(交换或者标记为负数) 判断某个值/几个值 存不存在🔻试用场景： 数组的所有数字都是从0开始或者1开始(正数) 并且对空间复杂度要求为O(1)🔻时间复杂度： O(n)🔻空间复杂度： O(n)🔻注意事项：🔸数字必须为正数🔸不能破坏单调性🟧模板📌通用模板public class Temple{ public int Solution(int[] nums) { int len = nums.length; for(int i=0;i&lt;len;++i){ int n =Math.abs(nums[i]); int idx = n-1; int res = markHandle(nums,idx); return res; } return -1; } int MarkHandle(int[]nums,int idx){ if(nums[idx]&lt;0){ return idx+1; }else{ nums[idx]*=-1; } }}public class Temple{ public int Solution(int[] nums) { int len = nums.length; for(int i=0;i&lt;len;++i){ int nextIdx = nums[i]-1; MarkHandle(nums,nextIdx,i); } for(int i=0;i&lt;len;++i){ if(i+1!=nums[i]) return i+1; } } void MarkHandle(int[]nums,int l,int r){ int t = nums[l]; nums[l] = nums[r]; nums[r] = t; }}🟧总结🔻思考1:为什么使用原地哈希?🔸因为可以原地操作数组 修改值 判断值 空间复杂度为O(1)🔻思考2:原地哈希本质?🔸本质就是利用数组的下标从0开始这一特性 使用数组下标当作索引" }, { "title": "单调栈", "url": "/posts/%E5%8D%95%E8%B0%83%E6%A0%88/", "categories": "算法", "tags": "单调栈", "date": "2023-10-07 02:34:00 +0000", "snippet": "单调栈🟧概述🔻含义：栈底到栈顶维持一个单调有序的栈单调栈就是栈里的数据递增或递减存放，也就是要做到有序，如果待入栈数据不符合栈里数据的有序性，则栈顶出栈，一直到栈里数据有序，最后将当前遍历到的元素栈插入到栈顶。我们将当前还没得到答案的下标暂存于栈内，从而实现「被动」更新答案。也就是说，栈内存放的永远是还没更新答案的下标。每次将当前遍历到的下标存入栈内，将当前下标存入栈内前，检查一下当前值是否...", "content": "单调栈🟧概述🔻含义：栈底到栈顶维持一个单调有序的栈单调栈就是栈里的数据递增或递减存放，也就是要做到有序，如果待入栈数据不符合栈里数据的有序性，则栈顶出栈，一直到栈里数据有序，最后将当前遍历到的元素栈插入到栈顶。我们将当前还没得到答案的下标暂存于栈内，从而实现「被动」更新答案。也就是说，栈内存放的永远是还没更新答案的下标。每次将当前遍历到的下标存入栈内，将当前下标存入栈内前，检查一下当前值是否能够作为栈内位置的答案（即成为栈内位置的「下一个更大的元素」），如果可以，则将栈内下标弹出。求最近的最大值使用 递减栈 反之最大栈 - &gt;max = Math.max(max,temp);max=Integer.MIN_VALUE;🔻试用场景： 找最近一个比当前值大或者小的左边和右边的坐标 空间优化时间🔻时间复杂度： O(n²) -&gt;O(n)🔻空间复杂度： O(n)🔻注意事项：🔸遍历初始化的数组🔸遍历方向:首遍历还是尾遍历🔸栈的单调性选择：降序还是升序🔸放入栈的是值：是放入下标还是下标对应的值🔸内循环比较：一定是比较下标对应的值 如果 存入的是值 那就不用🟧模板📌降序栈：求最近的最大值class Solution {\t\t//底部到顶部 依次递减 public int[] deSeqStack(int[] nums) { int len = temperatures.length; Deque&lt;Integer&gt; stack = new LinkedList(); for(){ while(!stack.isEmpty()&amp;&amp;nums[i]&gt;nums[stack.peek()]){ int preIdx = stack.poll();\t handle(); } stack.push(i); } }}📌 升序栈：求最近的最小值class Solution {\t\t//底部到顶部 依次递减 public int[] seqStack(int[] nums) { int len = temperatures.length; Deque&lt;Integer&gt; stack = new LinkedList(); for(){ while(!stack.isEmpty()&amp;&amp;nums[i]&lt;nums[stack.peek()]){ int preIdx = stack.poll();\t handle(); } stack.push(i); } }}🟧总结🔻思考1:为什么单调栈能避免暴力搜索？🔸使用空间换时间的方式去优化 额外维护一个单调栈 栈内记录元素下标 作为零时缓存 这个缓存是由近及远的 在第二个循环去缓存中 判断当前元素是否符合题意🔸根据模板 第二层循环也是没有遍历原来的数组 而是遍历栈的零时缓存 将O(n²) 降为 数组和栈的O(n) 遍历🔻思考2:单调栈本质？🔸单调栈本质上来源于单调性，一般可以理解为 当遍历到的元素的 不符合单调性的时候 拿他和栈顶元素比较 如果一直不符合 就一直栈顶元素出栈 直到符合预期🔻思考3:单调栈实际应用？🔸暂无🔻思考4:单调栈的限制条件？🔸空间O(n)" }, { "title": "Springmvc🤖️", "url": "/posts/SpringMVC-%EF%B8%8F/", "categories": "", "tags": "", "date": "2022-08-31 00:00:00 +0000", "snippet": "SpringMVC一.MVC1.MVC的解释:​\t🌟MVC模式是一种架构思想​\t\t1⃣️ M: Model-模型\t \t\t 指的是模型数据 即数据库的数据​\t\t2⃣️ V：View-试图 \t\t\t\t指的是前端的视图​\t\t3⃣️ C：Controller-控制器\t指的是控制器 用于连接前端视图层和后端的数据层 还有 把后台的数据进行逻辑处理后返回给前端的视图层2.MVC的优势​\t1⃣️解除各个...", "content": "SpringMVC一.MVC1.MVC的解释:​\t🌟MVC模式是一种架构思想​\t\t1⃣️ M: Model-模型\t \t\t 指的是模型数据 即数据库的数据​\t\t2⃣️ V：View-试图 \t\t\t\t指的是前端的视图​\t\t3⃣️ C：Controller-控制器\t指的是控制器 用于连接前端视图层和后端的数据层 还有 把后台的数据进行逻辑处理后返回给前端的视图层2.MVC的优势​\t1⃣️解除各个模块的耦合度​\t2⃣️便于系统的维护​\t3⃣️便于项目的管理和拓展二.MVC的执行流程1.前端发起一个Http请求 如果匹配DispatchServlet的请求路径 那么就让DispatchServlet去处理 2.DispatchServlet根据对应的请求信息 去HandlerMapping去寻找对应的Handler3.得到Handler后对其进行统一封装成HandlerAdapter 再去用同一适配器接口 调用具体的Handler4.处理完后会得到一个ModelAndView 返回给DispatchServlet5.DispatchServlet会将这个ModelAndView 使用视图解析器去解析 解析完毕后 返回一个View对象6.前端页面对View对象进行渲染三.SpringMVC的常用注解1.@RequestMapping -@RequestMapping(“comment”)@GetMapping、@DeleteMapping、@PutMapping、@PostMapping2.@RestController 标注为支持Rest风格的控制器层3.@CrossOrigin 解决跨域问题4.@Autowired 自动注入Spring容器中的类5.@RequestBody:表示接收前端的一个对象 并且绑定到控制器的方法参数上6.@RequestParam 表示 接收请求路径中传入的参数 并且绑定到控制器的方法参数上7.@PathVariable 接收路径中传入的请求参数 restful风格的四.拦截器1.拦截器会对请求进行拦截处理 2.处理逻辑​\t请求来到 首先通过preHandle()处理 如果为true 则放行到controller层进行逻辑处理 然后到postHandle()方法 然后进行视图解析 最后进入AfterCompletion3.具体实现​\t1⃣️一般先定义一个类 xxxxInterper 实现handlerInterper接口 然后实现其preHander()方法、postHander()、afterCompletion()方法​\t一般在preHander方法中 处理拦截信息 如果为true 则放行 为false则抛出异常​\t2⃣️ 然后定义一个 InterceptorConfig类 并且以@Configuration注入Spring中 然后写一个方法获取 xxxxInterper类实例 然后重写addInterceptors 把拦截器注册 并且 添加具体拦截到路4.拦截器和过滤器的具体区别​\t1⃣️拦截器是基于Spring组件不依赖Tomcat 而过滤器则是Servlet上的应用依赖Tomcat​\t2⃣️拦截器底层基于反射去实现的 而过滤器是基于函数回调实现的​\t3⃣️拦截器实现handlerIntercepetor接口 而过滤器实现javax.servlet​\t4⃣️拦截器拦截的是Contoller层的请求 而过滤器能拦截所有请求​\t5⃣️拦截器在controllor整个生命周期能多次调用 过滤器则只能在容器初始化时候调用" }, { "title": "Spring🍃", "url": "/posts/Spring/", "categories": "", "tags": "", "date": "2022-08-30 00:00:00 +0000", "snippet": "Spring(IOC、AOP)一.IOC1.概念​\tIOC是Inversion Of Control 意思为控制翻转 指对Java Bean 对象的控制 由程序员 反转到Spring容器​\t在Spring容器中 Bean对象被Spring容器管理着 Bean对象有着严格的生命周期 Bean对象存储在一个Map集合中​\t作用为 降低了耦合度和对象的依赖性 同时让资源容易管理2.实现​\t通过DI...", "content": "Spring(IOC、AOP)一.IOC1.概念​\tIOC是Inversion Of Control 意思为控制翻转 指对Java Bean 对象的控制 由程序员 反转到Spring容器​\t在Spring容器中 Bean对象被Spring容器管理着 Bean对象有着严格的生命周期 Bean对象存储在一个Map集合中​\t作用为 降低了耦合度和对象的依赖性 同时让资源容易管理2.实现​\t通过DI注入 依赖注入的方式 实现IOC​\t\t依赖注入：Spring对象将Bean对象的实例创建出来 提供给外部使用​\t\t\t依赖注入的实现方式：​\t\t\t\t\t·setter注入​\t\t\t\t\t·构造器注入​\t\t\t\t\t·接口注入3.Bean的生命周期​\t1⃣️通过反射实例化Bean对象​\t2⃣️填充Bean对象属性- populate()​\t3⃣️调用Aware接口的相关方法 完成对Beanname、BeanFactory、BeanClassLoader的赋值​\t4⃣️调用BeanPostProcess前置处理方法 设置 Application上下文​\t5⃣️调用initMethod方法 判断是否实现initializingBean接口 实现了调用AfterProeritesSet方法 没实现不调用​\t6⃣️调用BeanPostProcess后置处理方法 -Spring的AOP就是在这里实现的 注册desctrction相关回调接口​\t7⃣️getBean()方法获取Bean对象​\t8⃣️Bean对象的销毁4.IOC的底层实现​\t1⃣️通过creatBeanFactory方法创建 线程工厂​\t2⃣️开始循环创建对象 因为是单例方式创建所以默认是优先通过getBean或者getDoBean方式创建 如果找不到的话creatBean或者doCreatBean方式创建对象\t\t\t⬆️以上为通过反射实例化Bean​\t3⃣️填充对象的属性 populate方法​\t4⃣️其他初始化过程5.循环依赖♻️​\t1⃣️概述：循环引用 指 Bean之间相互引用 形成闭环​\t2⃣️分类：1.setter方式引起\t2.构造器引起​\t3⃣️解决：1.构造器引起的不能解决 抛出异常BeanCurrentCreation​\t\t\t\t\t 2.setter方式引起的循环依赖：可以通过 三级缓存➕提前曝光未初始化的完全的对象解决​\t\t\t\t\t\t·A发生对象通过反射实例化后 让其存放到三级缓存中 虽然对象不完美但还是能根据对象的引用定位到堆 结果就是让对象提前曝光​\t\t\t\t\t\t·然后发现其依赖B 然后去getBean(B) 没有的话去 creatBean(B) 然后就去创建B对象 然后又走流程​\t\t\t\t\t\t·然后发现B依赖A 然后去getBean(A) 去一二三级缓存找 找到了的话 B拿到了A的未初始化完全的对象 完成对象属性填充和初始化 存到自己缓存​\t\t\t\t\t\t·然后A拿到B初始化完全的对象 完成初始化​\t\t\t\t\t\t大概思路：A对象初始化完全后存到三级缓存中 发现 A依赖B 就去getBean 没有就去CreatBean 然后创建B 然后发现依赖A 就去Get A A在三级\t\t\t\t\t\t\t\t\t\t\t缓存了 拿到A对象 完成B的初始化 A拿到B对象 也完成初始化 结束二.AOP1.概念​\taop的意思为面向切面编程2.作用​\t把横切性的代码(日志监控等重复性代码) 和 核心业务代码分离 达到解耦 提高代码等复用性和可读性3.原理​\t总：通过动态代理去实现​\t分：​\t\tAOP是BeanPostProcess后置处理方法时候产生的 现有的IOC再有的AOP​\t具体流程：​\t\t\t代理对象创建​\t\t\t通过JDK动态代理或者CGLIB创建对象​\t\t\t执行方法的时候 调用产生的字节码文件 定位到Dynamic Advance Interpeter 类中的Interper方法​\t\t\t根据之前定义好的通知生成拦截器​\t\t\t然后从拦截器获取通知 然后执行4.JDK动态代理和CGLIB的区别​\t1.JDK动态代理是在运行时创建接口的代理实例 而CGLIB是用底层的字节码技术 在运行时创建类的代理实例​\t2.CGLIB有没有接口都可以用 为什么要用JDK动态代理​\t\t1⃣️JDK动态代理 创建对象的速度比 CGLB快 在单例模式下 但是CGLIB 效率性能高 对象多的话 频繁创建对象 用JDK" }, { "title": "Redis📦", "url": "/posts/Redis/", "categories": "", "tags": "", "date": "2022-08-28 00:00:00 +0000", "snippet": "Redis(原理、持久化和缓存淘汰机制等)参考书籍📚:《Redis设计与实现》一.Redis的原理1.简述·基于内存的K-V存储​\t\t数据直接存储在内存 不需要去磁盘进行读取数据 减少磁盘IO 减少至少两次的用户态到内核态到切换 减少cpu的切换·工作线程是单线程​\t\t单线程的优势：1.减少线程切换 旧线程的现场的保存和新线程的创建(底层是用户态到内核态的转变)​\t\t\t\t\t\t\t\t 2.减...", "content": "Redis(原理、持久化和缓存淘汰机制等)参考书籍📚:《Redis设计与实现》一.Redis的原理1.简述·基于内存的K-V存储​\t\t数据直接存储在内存 不需要去磁盘进行读取数据 减少磁盘IO 减少至少两次的用户态到内核态到切换 减少cpu的切换·工作线程是单线程​\t\t单线程的优势：1.减少线程切换 旧线程的现场的保存和新线程的创建(底层是用户态到内核态的转变)​\t\t\t\t\t\t\t\t 2.减少锁的创建和消除 减少死锁的发生·采用IO多路复用模型​\t\t\t1.名次解释：​\t\t\t IO多路复用模型是使用单个线程去监控网络中多个请求 即:网络中来自多路的IO请求 复用一个线程处理 当请求的事件准备就绪了 就通知程序去执行​\t\t\t2.优势:​\t\t\t\t-单线程的优势(内核态切换、锁的开销、不需要redis使用额外的线程去处理请求节省了额系统的开销)​\t\t\t3.IO多路复用的实现​\t\t\t\t·select():会把IO请求复制到内核中的一个数组中、然后🈚️差别的轮询这个数组、一旦感知到请求的事件准备就绪 那么通知程序去处理​\t\t\t\t\t\t\t缺点❌：1⃣️请求存在数组中 存在容量限制🚫.​\t\t\t\t\t\t\t\t\t\t\t 2⃣️无差别的轮询每次都要从头到尾遍历数组 时间复杂度是O(N)​\t\t\t\t\t\t\t\t\t\t\t 3⃣️请求信息在内核之间复制​\t\t\t\t\t\t\t\t\t\t\t 4⃣️只能无差别的轮询这个数组 只知道发生了事情 但是具体什么事件不知道​\t\t\t\t·poll():会把IO请求 创建成一个pollfd复制到内核中的一个链表结点中、然后🈚️差别的轮询这个数组、一旦感知到请求的事件准备就绪 那么通知程\t\t\t\t\t\t\t序去处理​\t\t\t\t\t\t\t缺点❌：1⃣️无差别的轮询每次都要从头到尾遍历数组 时间复杂度是O(N)​\t\t\t\t\t\t\t触发方式：水平触发：一旦感知到事件的发生 就启动程序去处理 此事水平触发就是 这次可以不处理 下一次仍然会通知​\t\t\t\t·epoll():会把IO请求注册到内核中的一颗红黑树上、表示感兴趣的事件、一旦感知到感兴趣的事件准备就绪 那么采用回调的方式去激活红黑树上的事\t\t\t\t\t\t\t 件 然后就通知对应的应用程序去处理​\t\t\t\t\t\t\t触发方式：边缘触发：一旦感知到事件的发生 就启动程序去处理 此事水平触发就是 这次必须处理 下一次不会通知​\t\t\t\t\t\t\t优势：只会去处理 那些活跃的事件 和 你总连接数无关 大大减少了重复触发的次数·基于文件事件处理模型​\t\t在IO多路模型的基础上 把IO请求有序 同步的放入一个队列中 然后把队列 中的数据按次序 发送到 文件事件分发器 再由这个分发器 分发到事件处理器中 是使用具体的处理器去处理二.持久化1.RDB·概述：RDB全称RedisDataBase 使用子线程对redis数据库以二进制序列化全量的数据备份 Redis默认持久化方式·优点：​\t\t\t\t·生成二进制文件 体积小 恢复快​\t\t\t\t·容易把当前数据移植·缺点：​\t\t\t\t·实时性不强​\t\t\t\t·创建线程是重量级操作 开消耗大​\t\t\t\t·数据完整性低：可能丢失数据·分类：​\t\t\t\t·同步持久化：使用SAVA命令-创建进行数据备份 备份期间 redis服务器会阻塞 直到备份完毕​\t\t\t\t·异步持久化：使用BGSAVA命令-创建一个子线程去进行数据备份 备份期间 redis服务器不会阻塞 只有创建线程的时候有阻塞 直到备份完毕2.AOF·概述：Append Only File 类似于MySQL的Binary日志 以独立日志的方式记录对redis的写操作 命令请求是先写到缓冲区 再写到AOF中 是增量备份 /追加备份下次启动时候 执行日志 进行恢复·优点：​\t\t\t\t·数据实时性强​\t\t\t\t·数据完整性强​\t\t\t\t·数据实时性强·缺点：​\t\t\t\t·写入时协议文本 体积大 恢复慢三.缓存淘汰机制1.概述​\t当内存空间不足以存下redis的键值对的时候 需要使用到缓存的淘汰机制2.方式 ​\t·直接报异常​\t·对所有的键：​\t\t-随机键淘汰​\t\t-LRU：最近最久未使用键淘汰​\t\t-LFU：最近最少未使用键淘汰​\t·对设置了过期时间的键：​\t\t-随机淘汰​\t\t-LRU：最近最久未使用淘汰​\t\t-LFU：最近最少未使用键淘汰​\t\t-TTL：移除有过更早过期时间的键" }, { "title": "Mysql🔢", "url": "/posts/MySQL/", "categories": "", "tags": "", "date": "2022-08-27 00:00:00 +0000", "snippet": "XMySQL(事物隔离级别、索引底层原理以及优化等)参考书籍📚:《MySQL技术内幕》一.事物的隔离级别1.总述​\t\t读未提交：什么都防止不了​\t\t读已提交：防止脏读​\t\t==可重复读==：防止脏读和不可重复读==(默认隔离级别)==​\t\t串行化： 防止脏读、不可重复读、幻读​\t\t脏读：一个事物读取了另一个事物未提交的操作​\t\t不可重复读：一个事物读取了另一个事物的修改操作​\t\t幻读：...", "content": "XMySQL(事物隔离级别、索引底层原理以及优化等)参考书籍📚:《MySQL技术内幕》一.事物的隔离级别1.总述​\t\t读未提交：什么都防止不了​\t\t读已提交：防止脏读​\t\t==可重复读==：防止脏读和不可重复读==(默认隔离级别)==​\t\t串行化： 防止脏读、不可重复读、幻读​\t\t脏读：一个事物读取了另一个事物未提交的操作​\t\t不可重复读：一个事物读取了另一个事物的修改操作​\t\t幻读：一个事物读取了另一个事物的增加和删除操作——依靠行锁解决:间隙锁、邻键锁​\t\t事物：用户对数据库的操作序列集合​\t\t事物的特性：​\t\t\tA-原子性：事物要么全做要么都不做​\t\t\t\t\t\t\t\t依靠undoLog📝实现​\t\t\t\t\t\t\t\tundolog:逻辑日志 在存储引擎层 记录的是 之前事物提交的所有数据 用于实现事物的原子性​\t\t\tC-一致性：事物执行前后状态保持一致 数据总量不会变多也不会变少 -能量的守恒​\t\t\t\t\t\t\t\t由 AID共同完成​\t\t\tI -隔离性：事物在提交之前 事物之间是隔离的 不会互相打扰 互相不可见​\t\t\t\t\t\t\t\t依靠MVCC实现：ReadView+UndoLog📝+隐藏的列​\t\t\t\t\t\t\t\tMVCC：多版本并发控制：一致性非锁定读 实现的无锁情况下保证对资源的原子性访问 基于cas算法实现 ​\t\t\t\t\t\t\t\t\t\t\t\t重复读和读已提交的具体实现\t\t\t\t\t\t\t\t​\t\t\t\t\t\t\t\t读视图的生成：创建该视图的事物id、事物最大id号、事物最小id号、活跃事物列表​\t\t\t\t\t\t\t\t1.当前事物id是否和创建事物id一致？一致的话直接读取​\t\t\t\t\t\t\t\t2.不一致的话 如果大于最大事物id+1 则不能读取 如果小于最小id则直接读取 如果两者之间 的话 去查看活跃的事物id列表​\t\t\t\t\t\t\t\t3.在活跃列表的话则不能读​\t\t\t\t\t\t\t\t4.不在的话 直接读取​\t\t\tD-持久性：数据库中的数据一旦保存了 就永久存在物理磁盘上​\t\t\t\t\t\t\t\t依靠redoLog📝实现：redoLog物理日志 在存储引擎层 记录的是 物理数据页的改动 然后持久化到物理磁盘 用于实现 事物的持久性二.索引1.底层原理​\t\t索引底层原理采用B+树这样一种数据结构​\t\tB+树:是一种多叉树 是一种矮胖树 ​\t\t\t\t\t它的非叶子结点存放 向下的指针 key值 不存放data ​\t\t\t\t\t\t\t叶子结点存放 向下的指针 索引key值 并且叶子结点是双向的有序链表​\t\t\t\t 叶子结点存放全量的数据 非叶子结点和叶子结点数据有重复​\t\t==索引的加载==​\t\t\t索引存放在磁盘中 需要用到它时 要去磁盘获取 然后 加载到内存中 才能使用​\t\t\t一般呢索引文件都很大 不能一次性加载完 那么就只能分批分块加载到内存 ​\t\t\t一般我们选择以块为单位加载到内存 每一块称之为 磁盘页 每一页mysql规定时16kb大小​\t\t\t每一个磁盘页对应了B+树的一个结点 就是说 根据B+树向下到下一个结点查找索引 要先去磁盘加载到内存 这就一次磁盘IO ​\t\t\t磁盘IO开销很大因为 涉及到用户态到内核态到转换 因为转换需要占用cpu处理时间 需要保存用户栈 切换 内核栈 开销很大​\t\t\t为了减少IO次数 我们要么就在固定大小的磁盘页中加载更多的索引区间 要么就减少树的高度​\t\t​\t\t🌟B树和B+树的区别：​\t\t\t1.叶子结点和非叶子结点的存储数据不同​\t\t\t\tB树非叶子结点存data数据 而 B+树不存​\t\t\t\tB+树有重复的结点​\t\t\t\tB+树叶子结点上一个双向排序的链表 添加和插入元素快​\t\t\t\tB+树的查询路径稳定​\t\t\t\tB+树的索引范围存储的比B树多得多 约1000倍 所以B+树高度小 IO次数少 ​\t\t为什么不用哈希表​\t\t\t1.哈希表虽然等值查询快 但是范围查询相当的慢 因为哈希表上无序存储的 所以每个结点都要从头开始遍历​\t\t为什么不用红黑树？​\t\t\t1.红黑树是二叉树 每次向下读取索引的时候 都要去磁盘中读取数据到内存才能使用 二叉树太深了 导致需要进行多次的磁盘IO 消耗资源2.作用​\t\t优点：​\t\t\t\t\t海量数据下 提升数据的查询速度和效率​\t\t\t\t\t索引的查询 默认使用了隐藏的优化器 提升性能​\t\t缺点：​\t\t\t\t\t索引的创建需要开销​\t\t\t\t\t索引的维护需要开销​\t\t\t\t\t索引占空间3.分类​\t\t主键索引​\t\t普通索引​\t\t唯一索引​\t\t组合索引​\t\t全文索引4.合适/不合适的使用场景​\t合适：​\t\t\t对一些数据进行频繁的查找​\t\t\twhere条件中的列​\t\t\t用于连接的列 ——userid = id​\t\t\t==位于主键的列==​\t\t\t==需要排序的列==​\t\t\t==需要范围查找的列==​\t🌟失效:-“走全表”​\t\t\t·like字段进行全字符匹配：like %xxx%——-落地了 使用es去优化​\t\t\t·select*语句—-平时不写select *​\t\t\t没有遵循最左匹配原则​\t\t\t·列上做了运算—-平时不做列运算​\t\t\t·where 条件中 用了!=/is not null/ &gt;和&lt; —平时注意5.技术名词​\t回表：通过辅助索引拿不到整行数据 只能通过辅助索引的value 再通过书签 回到 主键的聚簇key 再查找整行数据 ​\t\t\t\t回表过程会去磁盘中加载索引到内存有一次磁盘IO 所以尽量减少回表次数​\t覆盖索引：尽量通过辅助索引 能查找到想要的数据 不需要走回表 又去聚簇索引找一次 减少回表次数​\t索引下推：在组合索引中 通过最左匹配原则查找数据时候 如果对查找的数据找不到 那么需要回表 再回表之前如果有条件的判断 那么就必须先判断 这个操作是在存储引擎层去做的 ​\t最左匹配原则：​\t\t\t\t\t对于组合索引 索引的匹配从左到右依次开始6.聚簇索引非聚簇索引​\t1.聚簇索引：主键作为索引建立起来的B+树 通过key就可以得到整行数据data​\t2.非聚簇索引：不是用主键建立起来的B+树 data是对应主键B+树的key 还需要通过书签 访问一次主键索引 多一次磁盘IO 所以尽量减少磁盘非聚簇索引​\tInnoDB 支持1个聚簇索引和多个非聚簇索引​\tMyISAM 仅仅支持非聚簇索引三.MySQL调优1.索引优化通过索引去加快数据的查询索引的创建​\t\t1.创建表的时候 指定字段为索引​\t\t2.输入 creat index on 索引名 on 表名 字段名一条sql的执行时间？​\t ·使用show profiles;如何用索引进行优化？​\t1.使用explain执行计划配合对应 select查询语句 和设置的索引字段 查看是否走了索引​\t\t·type：是否走了索引​\t\t·key：理论上走的索引​\t\t·possible：实际上走的索引​\t\t·extra：是否使用了覆盖索引​\t2.索引类型的选取：​\t\t索引字段的类型要选择在满足条件下的最小容量 避免大材小用 因为在b+树中存储索引的多少取决于key的值 key占空间越小 存的索引范围越大​\t3.在充当where的条件的列设置索引​\t4.在表连接处设置索引​\t5.主键建立索引​\t6.减少回表、尽量索引覆盖2.SQL语句​ 4.SQL语句避免select*\t——&gt;不走索引走全表​\t5.like字段 避免 %xxx%\t——&gt;不走索引走全表​\t6.不在列上做运算​\t7.where条件判断时候 不取反 如!=/ is not null操作3.存储引擎​\t搜索引擎采用InnoDB​\tInnoDB和MyISAM区别​\t1.InnoDB 支持聚簇索引 MyISAM不支持​\t2.InnoDB 支持行锁 MyISAM不支持​\t3.InnoDB 支持事物 MyISAM不支持​\t4.InnoDB 支持外键 MyISAM不支持​\t5.InnoDB 相对复杂 MyISAM相对容易​\t6.InnoDB 跨平台性弱 MyISAM跨平台性强​​#####​⭐MVCC\t采用多版本号的方式去实现\t多版本并发控制\t\t一致性非锁定读\t\t针对读取数据\t\t读已提交和重复读取的一种具体的实现\t作用\t\t实现了读读不冲突 写回数据库的时候 再判断\t实现原理\t\t(每一条记录后面默认都有)隐藏字段\t\t\tDB—TRX—ID\t\t\t\t最近一次被哪个事务修改 记录其ID\t\t\tDB-Row-ID\t\t\t\t隐藏的主键\t\t\t回滚指针\t\t\t\t指向上一个历史版本记录\t\t\t\t\t历史版本存在undolog中\t\tReadView\t\t\t每次查询时候 生成一个readview提供一个快照给当前读的事务\t\t\t\tReadView组成\t\t\t\t\tcreator_trx_id\t\t\t\t\t\t创建这个readview的事务id\t\t\t\t\ttrx_ids\t\t\t\t\t\t活跃的事务id列表\t\t\t\t\tlow_limit\t\t\t\t\t\t最大事务id+1\t\t\t\t\tup_limit\t\t\t\t\t\t最小事务id\t\t\t\t怎么提供一个快照？提供哪一个快照？\t\t\t\t\t算法！\t\t\t\t\t\t判断 最新的事务id(当前进行操作的事物id) 和 creator_trx_id 是否相同\t\t\t\t\t\t\t相同\t\t\t\t\t\t\t\t直接读\t\t\t\t\t\t\t不相同\t\t\t\t\t\t\t\t事务id 大于 low_limit (大于最大)\t\t\t\t\t\t\t\t\t不能读\t\t\t\t\t\t\t\t事务id 小于 up_limit (小于最小)\t\t\t\t\t\t\t\t\t能读\t\t\t\t\t\t\t\tup_limit &lt; 事务id &lt; low_limit (在中间)\t\t\t\t\t\t\t\t\t事务id 是否在 活跃的列表(trx_ids)中？\t\t\t\t\t\t\t\t\t\t在\t\t\t\t\t\t\t\t\t\t\t不能读\t\t\t\t\t\t\t\t\t\t不在\t\t\t\t\t\t\t\t\t\t\t读取\t\t\t\tMVCC只在 读已提交 和 可重复的隔离级别下生效\t\t\t\t\t读未提交\t\t\t\t\t\t已经读取到最新数据了 已经读到当前读了\t\t\t\t\t串行化\t\t\t\t\t\tinnodb下规定使用锁\t\t\t\t事务在 读已提交 和 可重复的隔离级别 产生的read view 不同\t\t\t\t\t读已提交\t\t\t\t\t\t每次读取都产生一个 readview\t\t\t\t\t可重复读\t\t\t\t\t\t只在第一次读取的时候产生 readview 后续读取只 延用上面的readview\t\tUnDoLog\t\t\t历史版本内容包括\t\t\t\t最近一次修改的事务id号\t\t\t\t隐藏主键：row-id\t\t\t\t上一次操作的具体 代码\t\t\t\t上一次 的操作 是添加还是删除\t\t\t\t指向上一个历史版本的指针" }, { "title": "Juc💎", "url": "/posts/JUC/", "categories": "", "tags": "", "date": "2022-08-26 00:00:00 +0000", "snippet": "JUC(CAS、Volatile、Synchronized以及锁升级等)参考书籍📚:《Java并发编程的艺术》一.CAS1.概述​\t\tCAS全称(Compare And Swap) 是一种不使用锁而去实现锁功能的算法 也叫乐观锁、自旋锁2.为什么出现​\t\t常规使用锁会带来上下文的切换 最终导致用户态到内核态的切换 (多执行一次cpu的切换) 加锁释放锁 死锁 影响执行速度3.具体实现的算法​...", "content": "JUC(CAS、Volatile、Synchronized以及锁升级等)参考书籍📚:《Java并发编程的艺术》一.CAS1.概述​\t\tCAS全称(Compare And Swap) 是一种不使用锁而去实现锁功能的算法 也叫乐观锁、自旋锁2.为什么出现​\t\t常规使用锁会带来上下文的切换 最终导致用户态到内核态的切换 (多执行一次cpu的切换) 加锁释放锁 死锁 影响执行速度3.具体实现的算法​\t\t当从内存中读取一个数据出来 比如说 a=1​\t\t线程k把变量修改成2 —-&gt; a=2​\t\t在把a=2写回内存的期间 去查看原来的a有没有被修改过 ​\t\t\t没有则说明 当前k线程操作期间没有其他线程动过 -&gt;修改成功✅​\t\t\t如果有说明 当前k线程操作期间被其他线程动过 -&gt;修改失败❌4.优缺点·优点：cas实现了无锁并发 实现了无锁情况下 原子性的修改变量值 减少上下文切换·缺点：cas自旋时间过长会一直占用cpu资源 并且吞吐量低 🕘\t\t\t 只能保证一个变量的原子性 如果要保证多个那么需要用锁🔒\t\t\t ABA问题:如果在检查之前把修改过的值及时改回来 线程就检测不到 当前变量被别人使用过\t\t\t\t\t-解决?-加版本号 每次使用或者更新变量之前更新版本号-AtomicStampedReference5.底层原理​\t次级实现：Unsafe类中的compareAndSet() 方法：是一个本地方法 是硬件级别的方法​\t最终实现：lock cmpxchg二.Volatile​1.概述​\t\tVolatile是轻量级的Sychronized 除了原子性 其余的特性都有2.作用​\t\t保证线程的单一指令的原子性、可见性、有序性​\t\t​\t\t可见性:​\t\t\t\t\t定义：保证在多线程的情况下 使用的变量值永远是最新的​\t\t\t\t\t原理：==lock前缀指令== (lock addl $0x0,(%esp)) 保证变量被修改的时候及时推送回主存 然后当其他线程的缓存行有它时 致缓存行无效​\t\t\t\t\t实现：​\t\t\t\t\t\t\t当volatile变量被修改的时候 会通过总线把修改后的数据写回主存 写回主存时 通过缓存一致性协议把它的缓存行锁定 保证修改的原子性​\t\t\t\t\t\t\t其他线程在总线通过cpu的嗅探技术 嗅探到自己线程的数据的地址发生变化 那么就致缓存行无效 当下一次使用到该变量时候再去主存中获取\t\t有序性:​\t\t\t\t\t定义：为了提高程序执行的性能 编译器和处理器会对指令进行重新排序​\t\t\t\t\t分类：​\t\t\t\t\t\t\t\t编译器：单线程情况下不影响 语义的情况下 可以重新排序——JMM会禁止重排特定类型的编译器​\t\t\t\t\t\t\t\t处理器：如果不存在数据依赖则可以重新排序——JMM要求Java编译器在编译期间生成指令序列时 插入内存屏障来禁止指令重排​\t\t\t\t\t\t\t\t\t\t 内存屏障:​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tLoad-Load :读-读:A Load-Load B:A读完才能B读​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tLoad-Store :读-写:A Load-Store B:A读完才能B写​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tStore-Store:写-写:A Store-Store B:A写完才能B写​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tStore-Load :写-读:A Store-Load B:A写完才能B读​\t\t\t\t 原则：​\t\t\t\t\t\t\thappens-before:定义一些规则来禁止一些指令的重排序(改变结果的重排) 根据其规则提供的内存可见性保障来编程​\t\t\t\t\t\t\t只要不改变程序的执行结果(单线程程序和正确多线程程序) 编译器和处理器怎么优化都可以​\t\t\t\t\t\t\tas-if-serail:保证单线程内程序的执行结果不被改变,单线程程序执行代码时像是串行执行​\t\t\t\t\t\t\thappens-before:正确同步的多线程程序执行结果不改变,同步正确的多线程程序执行代码时像是串行执行​\t\t\t\t\t\t\t​\t\t\t\t\t\t\t规定：​\t\t\t\t\t\t\t\t\t·一个线程的所有操作 happens-before该线程的任意后续操作\t\t\t\t\t\t\t\t​\t\t\t\t\t\t\t\t\t·对一个锁的解锁happens-before对这个锁的加锁​\t\t\t\t\t\t\t\t\t==·对volatile变量的写happens-before 任意后续对这个volatile变量的读==​\t\t\t\t\t\t\t\t\t·如果A happens-before B, B happens-before C, 那么 A happens-before C​\t\t\t\t\t\t\t\t\t·启动线程时：ThreadA.start() 操作 happens-before 线程 A的任意操作​\t\t\t\t\t\t\t\t\t· 在线程A中执行TheadB.join() 并且成功返回 那么 线程B的任意操作 happens-before 线程A从ThreadB.join()操作成功返回\t\t​\t\t原子性: 弱原子性​\t\t\t\t\t通过happed-before原则的结论可知道 volatie的读 总能 得到 最新的 volatitle的写\t只要是voaltile变量 除了i++这一类的 都能保证原子性​\t\t\t\t\t实现原理：通过在编译器生成字节码的时候 插入内存屏障来实现 ​\t\t\t\t\t\t\t\t\t volatile写：​\t\t\t\t\t\t\t\t\t\t\t\t\t\t之前：Store-Store​\t\t\t\t\t\t\t\t\t\t\t\t\t\t之后：Store-Load​\t\t\t\t\t\t\t\t\t volatile读：​\t\t\t\t\t\t\t\t\t\t\t\t\t\t之前：Load-Load​\t\t\t\t\t\t\t\t\t\t\t\t\t\t之后：Load-Store​\t\t\t\t 为什么不能保证多指令的原子性？​\t\t\t\t\t修改volatile变量分为四步： 1）读取volatile变量到local ​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t2）修改变量值 ​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t3）local值写回​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t4）插入内存屏障，即lock指令 ​\t\t\t\t 显然前三步都是不安全的，取值和写回之间，不能保证没有其他线程修改3.应用单例模式下的Double Cheack Lock​\t1.出现原因：单例模式下会出现下线程安全的问题​\t\t\tnew 一个对象时:​\t\t\t\t\t1.分配内存空间 赋默认值​\t\t\t\t\t2.调用构造方法 赋初始值​\t\t\t\t\t3.栈中的引用对象 指向 堆中的实例对象的地址​\t\t\t其中2和3这两个步骤在多线程的情况下可能发生重新排序 导致拿到一个未正确初始化的对象而执行完毕​\t2.解决：使用volatile 关键字 在编译时候 加入Load Store屏障和 Store -Load 屏障 表示 只有当前这个线程写完才能读 防止指令的重排序​\t3.代码:public class singleton{ private static volatile singleton s; private singleton(){}; public singleton getInstance(){ if(s==null){ sychronized(this){ if(s==null){ s = new singleton(); } } } return s; } }​\t​三.Synchronized1.概述​\t\t多线程情况下为了保证线程执行安全(线程执行的有序性、可见性、原子性)使用锁去完成 确保同一个时刻最多只有一个线程执行同步代码2.作用​\t\t保证线程的原子性、可见性、有序性​\t\t​\t\t可见性:​\t\t有序性:​\t\t原子性: ​\t\t\t\t\t\t内存语意:推送到主存-获取最新值🤩​\t\t\t\t\t\t释放锁 JMM把线程对应的本地变量刷新到主存——对应于vlatile写——相当于线程向接下来要向获取这个锁的某个线程发信息​\t\t\t\t\t\t获取锁 JMM把线程对应的本地变量设置为无效 从而使被监视器保护的临界区代码必须从主存读取共享变量——对应于vloatile读——线程B接收了\t\t\t\t\t\t\t\t\t某个线程发出的的信息3.使用1.作用在方法：普通方法和静态方法\t普通方法：锁的是当前的实例对象\t静态方法：锁的是当前类.class对象2.作用在同步代码块：锁的括号内的对象3.🌟实现原理：基于一个Monitor对象去实现的 监视器锁本质又是依赖于底层的操作系统的 Mutex Lock（互斥锁）来实现的​ 任何一个对象都对应一个monitor 当monitor被持有的时候 将会处于锁定状态 线程执行到monitorenter时候​\t将尝试获取对象所对应的monitor所有权 即尝试获取对象的锁 如果获取到了监视器 就继续执行下去 直到结束 到了 monitorExit​\t 如果获取不到 则进入同步队列 线程阻塞住 直到获取到监视器的线程退出后发出通知 才能出队列​\t同步代码块：​\t\t在代码块开始的时候加 monitorenter 结束的时候加monitorexit(一个正常出口一个异常出口)​\t\t当线程执行到monitorenter的时候要先获得锁，才能执行后面的方法。​\t\t当线程执行到monitorexit的时候则要释放锁。​\t\t每个对象自身维护着一个被加锁次数的计数器，当计数器不为0时，只有获得锁的线程才能再次获得锁。​\t同步方法：\t​\t\t在class文件中 访问标识符被改为ACC_SYCHRONIZED 当线程要执行的方法被标注上ACC_SYNCHRONIZED时，需要先获得锁才能执行该方法4.通信​\t概述：线程的通信通过一个对象Object调用器其Object父类的wait()-notify()/notifyAll()进行通信(wait方法释放锁、notify方法:通知一个在对象上等待的线程 使其从wait方法返回 返回的前提是线程获取到了对象的锁)​\t细节：使用wait 、notify之前必须要对对象加锁-就是说对象以及获取到锁了-言下之意就是已经持有这个对象了​\t\t\t\twait方法调用后 必须释放当前锁 为什么？-因为要避免死锁(请求保持条件)​\t具体流程：线程的通信建立在线程的同步之上 因为需要等待线程在等待方法返回时 能感知到通知线程对变量做出的修改-&gt;锁的内存语义​\t\t\t\t1.当线程进入monitorenter 就尝试获取对象的monitor ​\t\t\t\t\t如果获取到了就 获取到对象的所有权​\t\t\t\t\t\t获取到对象所有权后 调用对象的wait()方法 就会进入等待队列 同时 释放持有的monitor对象​\t\t\t\t\t\t与此同时 另外一个线程B 进入monitorEnter 尝试获取monitor对象 刚好获取到 然后调用notify方法 把等待队列中的对象 移动到同步队列 然后线程B 正常退出 释放锁了 然后在同步队列的线程A 获取到了锁 就从wait返回继续执行​\t\t\t\t\t如果获取不到就 进入同步队列 等待获取对象执行到monitorexit的通知6.锁升级1.锁升级原因：\t\t\t\t\tSynchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的，监视器锁本质又是依赖于底层的操作系统的 Mutex Lock（互斥锁）来实现的。而操作系统实现线程之间的切换需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么 Synchronized 效率低的原因。因此，这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为 “重量级锁”。\t\t\t\t\tJDK1.6的优化-引入锁升级 为了减少锁的释放和创建所带来的开销 减少用户态到内核态之间的切换所带来的开销 所以引入锁升级2.前置知识:\t对象的结构(16字节)\t\t·对象头：\t\t\t\t\t\t\t·MarkWord(32位=4字节):\t\t\t\t\t无锁: Hashcode(25位) 分代年龄(4位)、偏向标记位(1位)[0]、锁标记位(2位)[01]\t\t\t\t\t偏向锁: 线程ID(23位)、Epoch(2位)、分代年龄(4位)、偏向标记位(1位)[1]、锁标记位(2位)[01]\t\t\t\t\t轻量级锁: \t\t\t\t\t\t\t\t 30位指向栈中锁记录的指针\t\t\t\t\t\t\t\t锁标记位(2位)[00]\t\t\t\t\t重量级锁: \t\t\t\t 30位指向重量级锁的指针\t\t\t\t\t\t\t\t\t锁标记位(2位)[10]​\t\t\t\t·Class Point:(4字节)虚拟机通过这个指针来确定这个对象是哪个类的实例 ​\t\t\t\t\t\t\t\t\t对应jvm类加载的第一步的第三小步”在内存中生成代表该类的.Class对象 程序可以通过这个对象 在方法区访问其的入口“​\t\t\t\t·(数组对象:) ·实例数据:((4字节)[不开启指针压缩]/(8字节)) ·填充:(4字节)[开启指针压缩]/(0字节)3.锁升级过程\t\t无锁: 没有加锁的对象\t\t偏向锁:\t\t\t\t定义:当某个线程一次获得锁时 并且没有线程和其争抢时 偏向于第一次获得锁的那个线程\t\t\t\t原因:Hotspot作者发现 大部分情况下锁不仅不存在竞争而且总是被同一个锁多次获取 为了让线程获得的锁代价更低 引入了偏向锁\t\t\t\t流程:\t\t\t\t\t\t添加偏向锁:\t\t\t\t\t\t当线程进入同步代码块获取到锁后 会在对象头和栈帧中的锁记录里面存储获得到的线程ID \t\t\t\t\t\t以后该线程在进入和退出同步代码块时 不需要 进行cas的加锁和解锁 只要简单的测试一下对象头中的MarkWord中偏向锁的线程ID是否\t\t\t\t\t\t是当前线程ID 如果成功则该线程获得锁 如果不是则 查看MarkWord中偏向锁的偏向锁位置是否为1 \t\t\t\t\t\t为1 尝试用CAS把MarkWord的线程Id改成当前当前线程ID 如果不为1 则说明还不是偏向锁 则使用CAS加锁\t\t\t\t\t\t\t比较点:是否为当前线程 是否设置了偏向锁标记位​\t\t\t\t 撤销偏向锁:​\t\t\t\t\t\t\t当锁出现线程竞争的时候 需要进行锁升级 升级成轻量级锁 要把偏向锁撤销 ​\t\t\t\t\t\t\t偏向锁的撤销需要等到全局的安全点-这个时间点没有正在执行的字节码 ​\t\t\t\t\t\t\t首先会把拥有偏向锁的线程暂停 然后查看持有偏向锁的线程是否活跃 ​\t\t\t\t\t\t\t如果不活跃则 对象头设置为无锁状态 如果活跃拥有偏向锁的栈会被执行 便利对象的锁记录​\t\t\t\t\t\t\t栈中的锁记录和MarkWord要么偏向于其他线程 要么就恢复到无锁或者标记为对象不适合作为偏向锁​\t\t\t\t\t\t\t最后唤醒暂停的线程​\t\t\t\t\t\t偏向锁的暂停:​\t\t\t\t\t\t\t偏向锁默认启动 但是会延迟几秒钟 如果明知一定有线程竞争 可以关闭偏向锁 直接进入 轻量级锁​\t\t轻量级锁:​\t\t\t\t\t\t定义：也叫做自旋锁 当锁有轻量的线程竞争的时候 锁状态升级为轻量级锁​\t\t\t\t\t\t加锁：在进入同步代码块前 会在当前线程的栈帧中生产一个锁记录对象然后把对象头的markword信息复制到锁记录​\t\t\t\t\t\t\t\t\t然后线程将尝试用把CAS把markword的前30位的指针 指向 这个锁记录​\t\t\t\t\t\t解锁：用CAS把栈帧中的MarkWord去替换回到对象头 如果替换不成功则说明 存在锁竞争 就升级成重量级锁\t\t\t\t\t​\t 重量级锁: ​\t\t\t\t\t\tJDK1.6-自旋超过10次，升级为轻量级锁 如果线程数量过多 超过 cpu核数的一半 消耗CPU过大 不如升级成重量级锁进入等待队列​\t\t处于重量级锁状态下 没获取到锁的线程 会被阻塞 进入阻塞队列 线程挂起 不占用cpu资源​\t\t\t·重量级锁的原理：JVM中每个对象都会有一个’监视器’，监视器和对象一起创建、销毁。监视器相当于一个用来监视这些线程进入的特殊房间，其义务\t\t\t\t\t是保证（同一时间）只有一个线程可以访问被保护的临界区代码块 \t​\t\t\t·Hotspot虚拟机中，监视器是由C++类ObjectMonitor实现的 \t\t​\t\t\t\t组成：Cxq：竞争队列(Contention Queue),所有请求锁的线程首先被放在这个竞争队列中 ​\t\t\t\t\t\t EntryList：Cxq中那些有资格成为候选资源的线程被移动到EntryList中​\t\t\t\t\t\t WaitSet：某个拥有ObjectMonitor的线程在调用Object.wait()方法之后将被阻塞，然后该线程将被放置在WaitSet链表中获得到minitor的对象会\t\t\t\t\t\t\t\t\t\t\t\t进入owner \t​\t\t\t·重量级锁会发生线程的上下文切换，从用户态切换到内核态。系统调用是内核态为用户态进程提供的Linux内核态下互斥锁的访问机制，系统调用就会\t\t\t从用户态切换到内核态，这种切换是需要消耗很多时间的，而JVM重量级锁使用了Linux内核态下的互斥锁mutex。各种锁的比较\t\t\t\t偏向锁： \t\t适合只有一个线程访问同步代码块 加锁解锁不要耗费资源 \t\t但是 如果存在多个线程的锁竞争则会带开 偏向锁撤销的消耗​\t\t\t\t轻量级锁： \t\t适合追求响应比的场景 同步代码块执行速度很快 线程不会阻塞 \t\t但是 如果始终得不到锁竞争的线程 则会空耗cpu资源​\t\t\t\t重量级锁： \t\t适合吞吐量高的场景 同步代码块时间长 线程之间竞争不自选 而是挂起 不耗费资源 \t\t但是 线程会阻塞 等待时间长 响应比低四.AQS定义:​\t\t\t\tAbstractQueueSynchronized 抽象队列同步器 是构建锁和其他同步组件的基础框架 采用模版方法模式组成:​\t\t\t\t由一个volatile修饰的==state==(表示资源)和 一个 ==双端双向同步队列==(占有资源的在队头 没有获取到的在队尾)组成实现:​\t\t\t\t当线程修改state值时 尝试用修改state的值 成功构建成一个结点插入队头 因为只有一个线程去成功获取到同步状态 所以不要cas保证​\t\t\t\t\t\t\t不成功 则 把当前线程和等待状态信息 构建结点 用CAS的方式插入队尾 并且阻塞结点的线程​\t\t\t\t当线程使用完资源后 释放资源 发出通知 后续结点又可以通过cas修改state值方法:​\t\t\t\t==AQS可重写的方法:==​\t\t\t\ttryAcquire() 独占式获取同步状态/获取锁 如果符合预期则用cas修改​\t\t\t\ttryRelease() 独占式释放同步状态/获取锁 如果符合预期则用cas修改​\t\t\t\ttryAcquireShared() 共享式获取同步状态/获取锁 如果符合预期则用cas修改​\t\t\t\ttryReleaseShared() 共享式释放同步状态/获取锁 如果符合预期则用cas修改​\t\t\t\t==AQS的模版方法:==​\t\t\t\tacquire() 独占式获取同步状态/获取锁 如果成功则返回 不成功加入同步队列等待 该方法重写tryAcquire()方法​\t\t\t\tacquireInterruptibly() 独占式获取同步状态/获取锁 和acquire()相同只是方法会响应中断 ​\t\t\t\ttryAcquireNanos() 在acquireInterruptibly()基础上加了超时限制 如果在一个时间限制内没有获取到锁则返回false​\t\t\t\tacquireShared() 共享式获取同步状态/获取锁 如果成功则返回 不成功加入同步队列等待 该方法重写tryAcquire()方法​\t\t\t\tacquireSharedInterruptibly() 共享式获取同步状态/获取锁 和acquire()相同只是方法会响应中断 ​\t\t\t\ttryAcquireSharedNanos() 在acquireInterruptibly()基础上加了超时限制 如果在一个时间限制内没有获取到锁则返回false​\t\t\t\t​\t\t\t\trelease()独占式释放锁​\t\t\t\treleaseShared()共享式释放锁五.各种锁的对比CAS和Synchronized的区别1.加锁的开销：死锁 加锁 解锁 线程切换 内核态到用户态的切换 线程阻塞等待时间长–追求吞吐量2.CAS的空循环占cpu资源 线程不会阻塞 –追求相应比Volatile和Syncronized区别1.volatile是弱原子性、只能保证单一指令的原子性 而Snchronized不是 保证复合指令的原子性2.作用对象：volatile作用在变量 范围单一 而 Synchronized 可以作用在代码块和方法上 可以作用在多个变量3.底层实现：volatile是依靠lock addl 而Synchronized依靠 lock cmpexchge4.是否阻塞对象：volatile不会阻塞对象 而Synronized对于那些没有拿到锁的对象会阻塞进入同步队列5.编译器优化：volatile修饰的变量保证不会被编译器优化(除了那些不改变结果的编译器优化) synchronized 修饰的代码块会被编译器优化Lock和Syncronized区别1.Lock是接口而Syncronized是关键字2.Lock显式加锁而Syncronized隐式加锁3.Lock拓展了很多Synchronized的功能:\t1&gt;.可中断加锁\t2&gt;.可超时加锁\t3&gt;.非阻塞加锁4.Lock作用在代码块而Synchronized作用在代码块和方法5.底层原理：\t1&gt;.Lock是AQS去实现：CAS➕Volatile ——&gt; Lock CMPEXCHG➕Lock指令\t\tAQS：抽象队列同步器是构建锁和其他同步组件的基础框架\t\t组成： 由一个volatile修饰的state(表示资源)和 一个 双端双向队列(占有资源的在队头 没有获取到的在队尾)组成\t\t\t\t\t当线程修改state值时 尝试用cas修改state的值 成功构建成一个结点插入队头 不成功 则构建结点用CAS的方式插入队尾\t\t\t\t\t当线程使用完资源后 释放资源 发出通知 后续结点又可以通过cas修改state值​\t2&gt;.Sychronized是通过Monitor去实现：汇编底层是Lock CMPEXCHG指令——&gt;操作系统底层是mutex​\t\t底层是c++的monitor实现的：每个对象都有monitor 当进入同步代码块后 首先需要获取monitor对象 如果获取到了就可以进入代码块内 就持有monitor​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t如果获取不到则进入cxq竞争队列 竞争队列的线程有可能进入同步队列 同步队列的线程 需要等待 持有monitor的线程退出\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t同步代码块后释放持有的monitor对象才能再次去获取锁6.Lock有一个同步队列和多个等待队列 而 Sychronized只有一个同步队列和一个等待队列​\t在lock中获取完锁后 调用await方法 加入等待队列 此过程不需要cas去保证 因为在此之前 线程一直是持有锁的 通过锁保证没有其他线程去竞争7.通信：Lock采用condition机制去通信：await()-signal()/signalAll() 而 Synchronized 采用 wait()和notify()/notifyAll()去实现8.Lock是可公平可不公平的锁 而Sychronized是不公平锁\t公平的含义: 先对锁进行获取的请求先被满足那么就是公平锁\t实现原理：在尝试获取锁的时候 需要在AQS的队列中查看当前获取资源的结点是否有前驱结点 有的话就返回不继续执行 没有的话则可以尝试获取资源\t作用：公平锁可以防止线程饥饿 但是会频繁的切换线程上下文-用户态到内核态的转换频繁-导致cpu占用高开销大最终导致吞吐量低9.Lock加锁后 线程进入等待态 而 Synchronizd 则是进入阻塞态10.都是可重入锁\t重入的概念：线程获取完锁之后还能对资源进行反复的获取锁 \t实现：\t\t\t1.验证是否是同一个线程获取锁 \t\t\t2.如果是成功获取锁 则需要对内部一个计数器进行自增 执行完后释放锁需要对其进行自减 \t\t\t\t当为0的时候 表示最终成功释放" }, { "title": "Jvm⚙️", "url": "/posts/JVM-%EF%B8%8F/", "categories": "", "tags": "", "date": "2022-08-24 00:00:00 +0000", "snippet": "JVM虚拟机(内存区域、垃圾回收机制、类加载机制等)参考书籍📚:《深入理解Java虚拟机》一.内存区域1.程序计数器:记录当前线程在class类文件中运行到第几行2.栈:3.堆:4.方法区:二.垃圾回收机制1.什么是垃圾？没有被引用的对象 即死亡对象 就叫做垃圾怎么判定为对象是否被引用?​\t-1.引用计数算法​\t\t每次对象被引用计数器就加一 取消引用就减一 虽然实现方法很简单 但是无法解决=...", "content": "JVM虚拟机(内存区域、垃圾回收机制、类加载机制等)参考书籍📚:《深入理解Java虚拟机》一.内存区域1.程序计数器:记录当前线程在class类文件中运行到第几行2.栈:3.堆:4.方法区:二.垃圾回收机制1.什么是垃圾？没有被引用的对象 即死亡对象 就叫做垃圾怎么判定为对象是否被引用?​\t-1.引用计数算法​\t\t每次对象被引用计数器就加一 取消引用就减一 虽然实现方法很简单 但是无法解决==循环引用==的问题​\t​\t-2.可达性分析算法​\t\t每次去清理垃圾时候 从一个叫做GC Root的==根对象==作为起始结点开始向下遍历 如果GC Root 下没有相关联的引用或者说是==引用链== 则对象不可达 是垃圾 需要清理 反之 可达 不是垃圾​\t\t🌟可以作为GC Root的对象:​\t\t\t·虚拟机栈的引用对象:栈帧中的本地变量表:参数、局部变量、本地变量​\t\t\t·本地方法栈中JNI引用对象:本地方法​\t\t\t·方法区中 静态变量引用对象:java类的引用类型静态变量​\t\t\t·方法区中 常量引用对象:字符串常量池中的引用​\t\t\t·虚拟机内部的引用对象:基本数据类型对应的Class对象、常驻异常对象(空指针、OOM)、系统类加载器​\t\t\t·所有同步锁持有的对象:Synchronized​\t\t​\t\t三色标记法​\t\t\t把遍历GC Root过程中遇到的对象 按照是否访问过这个条件标记成以下三个颜色​\t\t\t白色：在可达性分析完毕后 如果是白色 则说明垃圾收集器没有访问过 说明是对象不可达的 是垃圾​\t\t\t黑色：表示对象已经被垃圾收集器访问过 并且该对象的所有引用都被扫描过了 说明对象是可达的 不是垃圾 黑色对象不能直接指向某个白色的对象​\t\t\t灰色：表示对象被垃圾收集器访问过了 但是该对象的有一些引用还没被扫描过​\t\t问题：黑色对象被误认为白色对象​\t\t解决：增量更新和原始快照​对象真正的死亡💀​\t\t当被标记为不可达对象时候 不一定是对象真正的死亡 还需要进行一次判断才能死亡宣告​\t\t​\t \t1.进行可达性分析后 GC Root下没有 引用链 则说明对象不可达 对象被第一次标记​\t\t\t\t-可达性分析后 对象不可达​\t\t 2.如果对象的finalized()方法==没有==被覆盖或者调用 则进入 一个F-Queue队列中 ​\t\t\t随后通过一个Finalizer线程执行他们的finalize()方法 ​\t\t\t如果此时对象==没有==和引用链上任意一个对象产生关联 那么就被真的判定为死亡对象​\t\t\t\t对象没有覆盖或者使用finalized()方法 并且 随后 没有和引用链上的对象产生关联 则对象真正死亡2.引用的分类​\t-强引用​\t\t Object obj = new Object();​\t\t即使堆内存空间不足、宁愿报异常也不不会被GC清理​\t-软引用​\t\t堆内存空间足够大时候 不会被清理 当内存紧张的时候 就会被清理​\t-弱引用​\t\t对象引用只会存活到下一次GC垃圾回收之前​\t-虚引用​\t\t任何时候都可能被垃圾回收2.垃圾回收算法📒·标记清除算法​\t区域：​\t概述：先在GC区域进行通过可达性分析 进行 ==存活对象的标记== 统一清除回收♻️未标记的对象​\t优点：提高系统吞吐量​\t缺点： 1.执行效率不稳定 如果堆中有大量对象 而且对象都需要被回收 执行效率就很低下 ​\t\t\t\t 2.标记-清除后有大量内存碎片🧩 导致大对象得不到分配空间而进行垃圾回收​\t细述：🈚️·标记复制算法​\t区域：针对堆中==年轻代==的算法 因为年轻代中的对象 来的多 ==但是死的快 最后剩下的对象很少== 每次复制的量少​\t概述：先在GC区域进行通过可达性分析 进行 ==存活对象的标记== 然后 ==复制存活对象另一块年轻代内存中== 最后清理之前的那一块年轻代区域​\t优点：不需要担心内存碎片的问题​\t缺点：浪费空间太大了 ​\t详细：​\t\t\t把年轻代分为：Eden、Survivor From、Survivor To 三个区域(8:2:2)​\t\t\t第一步 在Eden 区域进行 对象的收集和标记 ==MiniorGC== 然后 存活对象复制到 SF 之后清理 Eden 最后 对象 age +1​\t\t\t第二步 在Eden和SF区进行 对象收集和标记 ==MiniorGC== 然后 存活对象 复制到 ST 之后 清理 Eden和SF 对象age +1​\t\t\t第三步 把SF和ST区域 进行对换 然后 从第二步开始一直循环​\t\tTIP:==空间分配担保== 当一次 MiniorGC 后 复制到对应 survivor区域 空间不足​\t\t\t具体步骤:​\t\t\t\t\t1.进行MiniorGC之前 虚拟机对==老年代最大可用空间==进行判断 判断其==连续可用空间是否 大于新生代所有对象总大小==​\t\t\t\t\t2.如果大于说明装的下 则这次MinorGC是安全的 否则是不安全的​\t\t\t\t\t3.如果不安全 则查看 虚拟机 ==是否允许担保失败== ​\t\t\t\t\t4.如果允许 担保失败 则查看 ==老年代最大连续可用空间== 是否 大于 ==年轻代晋升到老年代的平均对象大小==​\t\t\t\t\t5.如果大于 说明 平均条件下 是安全的 ==则进行一次MiniorGC 否则 进行Full GC==·标记整理算法​\t区域：针对堆中==老年代==的算法 因为老年代存在大量的对象 标记复制算法效率太低下​\t概述：先在GC区域进行通过可达性分析 进行 ==存活对象的标记== 然后 让存活的对象向内存空间一端移动 然后清理掉内存边界以外的内存​\t优点：提高系统吞吐量​\t缺点：每次移动对象 是一个开销很大的操作 需要暂停用户线程进行Stop the word ​\t细述：🈚️3.垃圾收集器📒​\t基于分代收集理论:​\t\t年轻代：对象存活少 采用复制算法➕serial(单线程) / parNew(多线程并行) / parallel scavange(多线程并发 吞吐量高 但响应时间慢)​\t\t老年代：对象存活多 采用标记-清除算法 ➕ serial old / parallel old / CMS(多线程 吞吐量低 但 响应时间快)​\t\t老年代、年轻代：G1垃圾收集器==年轻代==·Serial​\t区域：年轻代​\t算法：复制算法​\t概述：单线程的垃圾收集器 实现方式简单 但是单线程的方式 会导致在垃圾收集的时候必须暂停用户线程 stop the word 用户体验感不好​\t优点：实现方式简单高效 没有线程之间的切换 并且它的所有收集器中额外内存消耗最小的​\t缺点：垃圾收集的时候必须暂停用户线程 stop the word 用户体验感不好·ParNew​\t区域：年轻代​\t算法：复制算法​\t概述：Serai的多线程的并行版本 GC线程使用多个线程 进行垃圾回收 垃圾收集的时候必须暂停用户线程 stop the word 用户体验感不好​\t优点：GC线程使用多线程 能在垃圾收集的时候 使用多条线程去开启任务​\t缺点：垃圾收集的时候必须暂停用户线程 stop the word 用户体验感不好·Parallel Scavenge​\t区域：年轻代​\t算法：复制算法​\t概述：多线程并行 可控制的吞吐量 吞吐量优先 ​\t优点：GC线程使用多线程 能在垃圾收集的时候 使用多条线程去开启任务​\t缺点：垃圾收集的时候必须暂停用户线程 stop the word 用户体验感不好==老年代==·Serial Old​\t区域：老年代​\t算法：标志整理算法​\t概述：serial 的老年代版本 单线程的垃圾收集器 实现方式简单 单线程的方式 会导致在垃圾收集的时候必须暂停用户线程 stop the word 用户体验感不好​\t优点：实现方式简单高效 没有线程之间的切换 并且它的所有收集器中额外内存消耗最小的​\t缺点：垃圾收集的时候必须暂停用户线程 stop the word 用户体验感不好·Parallel Old​\t区域：老年代​\t算法：标记整理算法​\t概述：Parallel Scavenge 老年代版本 多线程并发收集 可控制的吞吐量 吞吐量优先 ​\t优点：GC线程使用多线程 能在垃圾收集的时候 使用多条线程去开启任务​\t缺点：垃圾收集的时候必须暂停用户线程 stop the word 用户体验感不好·🌟CMS(Concurrent Mark Sweep)​\t区域：老年代​\t算法：标记清除算法​\t概述：一种追求最短回收停顿时间 低停顿的垃圾回收器​\t优点：最短的回收停顿时间 并发收集​\t缺点：​\t\t\t\t1.采用并发清除算法 会产生内存碎片 不好清除 可能导致提前的Full GC​\t\t\t\t2.面向并发设计 对cpu处理器资源比较敏感 会占用一部分线程 导致应用程序变慢 ==降低总吞吐量==​\t\t\t\t3.无法处理浮动垃圾(并发标记和清除 时gc和用户线程 同时运行 此时用户线程可能有新的垃圾对象 只能等到下一次再清理) 可能导致一次Full GC​\t详述：​\t\t\t\t初始标记：暂停用户线程 开始GC线程 去标记GC Root能直接关联到的对象​\t\t\t\t并发标记：GC线程开启的同时 开启用户线程 去遍历整个GC Root引用链​\t\t\t\t重新标记：用户线程暂停 重新去标记产生变化的引用 由于用户线程的使用 导致之前标记的引用发生变化​\t\t\t\t并发清除：开启用户线程的同时 同时开启GC线程去清理不可达对象·🌟G1(Garbage First)​\t区域：年轻代和老年代​\t算法：标记清除算法​\t概述：不再进行分区的垃圾收集 面向堆内存任何部分组成回收集 把堆内存划分为大小相等的独立区域Region 每个Region都可以是Eden SF ST 或者老年代​\t\t\t\tG1收集器 去跟踪每个Region里垃圾的价值大小 把那些最有价值的内存区域进行回收 (价值即:回收空间的大小以及回收所需要的时间) ​\t优点：工作线程 并行收集 ==用户可以指定期望停顿时间==(分析每个Region的花费成本 得出平均值、标准偏差 通过这些信息去预测停顿时间)​\t缺点：​\t\t\t\t1.Region数量比传统的收集器要多 因此G1收集器比其他传统的垃圾收集器有更多的内存占用​\t详述：​\t\t\t\t初始标记：暂停用户线程 开始GC线程 去标记GC Root能直接关联到的对象​\t\t\t\t并发标记：GC线程开启的同时 开启用户线程 去遍历整个GC Root引用链 找出要回收的对象 遍历完成后 还要处理在并发时有引用变化的对象​\t\t\t\t最终标记：用户线程暂停 用于处理并发标记后 仍遗留下来的那最后少量的记录​\t\t\t\t筛选回收：用户线程暂停 对Region的价值和成本进行排序根据用户期望停顿时间进行定制回收计划 由多条线程并行完成三.类加载机制1.类加载机制的概述·把class类文件 加载到内存 并且对数据进行校验 转换解析和初始化 最终形成可以被虚拟机直接使用的java类型·把整个过程都是在程序的运行期间完成的2.类加载机制的时机·解析阶段不一定严格按照类加载的顺序来 某些情况下可以在初始化阶段后执行(Java的动态绑定)·以下六种情况初始化必须立刻执行1.遇到new、getstatic、putstatic、invokestatic 这四条字节码指令 \t·new关键字实例化对象\t·读取一个非final的静态字段\t·调用静态方法2.进行反射调用时候3.初始化时 发现没有对父类进行初始化 必须立即对父类进行初始化\t如果是类的话 父类没有初始化 那么必须先去初始化 如果是接口 父接口没有初始化 不要求其父接口都完成了初始化只有真正使用到的时候才会初始化4.虚拟机启动时 主类必须进行初始化5.当接口中定义了JDK8新加入的默认方法 如果实现类发生了初始化那么 接口要在它之前初始化3.类加载机制的过程·加载​\t·在class类文件中方法区的常量池的符号引用找到代表该类的==全限定名== 将其转化为代表该类的二进制字节流​\t·把该字节流代表的静态数据结构转化成方法区的动态数据结构​\t·在内存生成一个代表该类的class对象 程序通过这个对象 可以访问 方法区中该类各个数据·验证​\t·class类文件格式验证：魔数号、主次版本号、常量池是否有不支持的类型​\t·元数据验证：这个类是否有父类、这个类的父类是否继承了不允许被继承的类​\t·字节码验证：对类的方法体进行校验 保证不会对虚拟机做出危害的行为​\t·符号引用验证：符号引用的类、字段、方法能否被当前类访问·准备​\t·通常情况下把非final的静态类型的变量进行内存的分配以及默认值的设置​\t·特殊情况下如果是final 修饰的静态变量 那么就不会进行默认值的分配 而是设置为指定的值 ​\t\t-原理是 ==类字段的字段属性表中存在 ConstantValue属性== 在准备阶段就会被设置为ConstantValue的值·解析​\t把class类文件的中方法区的符号引用改为直接引用​\t符号引用：一组符号来描述所引用的目标 符号可以是任何形式的字面量​\t直接引用：直接指向目标的指针 间接定位到目标的句柄·初始化​\t使用构造器的clinit()方法 对非final修饰的变量进行类的初始值的赋值4.类加载器类加载到第一步加载:通过类的全限定名找到该类 并且把转化成对应的二进制字节流这一步是在虚拟机外部去完成去做这一步的东西叫做 类加载器类加载器是加载类的对于任意一个类都必须由加载这个类的加载器和类共同确认在虚拟机的唯一性·启动类加载器​\t把java home /lib 下的类加载到虚拟机​\t ====启动类加载器 底层是c++实现的 虚拟机自身的一部分==​\t ==其余类加载器 底层是java实现的 存在于虚拟机外部 继承classLoader类==·扩展加载器​\t把java home /lib/ext 下的类加载到虚拟机·应用程序类加载器​\t把class path下的类加载到虚拟机 如果用户没有自定义类加载器 ==那么应用程序类加载器就是默认的类加载器==·自定义类加载器​\t继承classLoader类5.双亲委派模型·概述当收到一个类加载的请求的时候 当前类加载器首先不会去处理而是去查看其父类加载器 如果有的话就交给上层的父类加载器 没有的话就自己处理·为什么这么做基础类都是被最上层的启动类加载器加载 在各个类加载器中保证是同一个类 保证java程序的安全和稳定 保护程序安全， 防止核心API被随意篡改·双亲委派模型的打破1.线程上下文类加载器\t基础类都是由最上层的启动类加载器加载的 如果基础类型想调回用户代码 可以打破双亲委派模型2.代码热部署\t在OSGI的环境下 类加载器不再是双亲委派模型下的树型结构 而是更加复杂的网状结构3.只要重写loadClass方法就可以破坏\t例子：tomcat自定义了类加载器，重写loadClass方法使其优先加载自己目录下的class文件，来达到class私有的效果。·缺点❌顶层的ClassLoader 无法访问底层的 ClassLoader 所加载的类" }, { "title": "Os Inputandoutput", "url": "/posts/Os-InputAndOutput/", "categories": "", "tags": "", "date": "2022-08-18 00:00:00 +0000", "snippet": " IO硬件原理1.IO设备分类\t块设备：信息存储在固定的大小到块中 每个块有自己的地址 块设备的基本特征是每个块都能独立于 其他块而读写 常见的块设备:磁盘、USB\t字符设备：以字符为单位发送或接收一个字符流 不考虑任何块结构 常见的块设备:打印机、鼠标、网络接口2.设备控制器​\tIO设备由机械部件和电子部件组成​\t而电子部件就叫做 设备控制器 常常以usb插槽的形式出现​\t作用：把串行的...", "content": " IO硬件原理1.IO设备分类\t块设备：信息存储在固定的大小到块中 每个块有自己的地址 块设备的基本特征是每个块都能独立于 其他块而读写 常见的块设备:磁盘、USB\t字符设备：以字符为单位发送或接收一个字符流 不考虑任何块结构 常见的块设备:打印机、鼠标、网络接口2.设备控制器​\tIO设备由机械部件和电子部件组成​\t而电子部件就叫做 设备控制器 常常以usb插槽的形式出现​\t作用：把串行的位流转化成字节块 并进行必要的错误校正工作 字节块在控制器的缓冲区中进行组装 然后对校验和进行校验 如果没有错误就复制到主存3.cpu和设备控制器的通信​\tcpu通过设备控制内部的寄存器来对设备进行读写操作​\t此外为了提高数据交换效率 某些设备控制器中还有可读写的缓冲区buffer​\tcpu怎么和设备的控制寄存器和缓冲区通信?​\t1.给每个寄存器分配一个IO端口号​\t\t通过对控制寄存器的Port内容读写 并将结果写入cpu的寄存器中​\t\t但这种方式的内存地址空间和io地址空间不同​\t2.把每个寄存器映射到内存上​\t\t通过对控制寄存器的Port内容读写 并将结果写入cpu的寄存器中​\t\tIO内存映射的优缺点​\t\t1.优点：​\t\t\t\t1.1 对于内存映射IO 设备控制寄存器只是内存中的变量 可以直接使用c语言 而 不是用IO内存映射则需要某些 汇编代码 而c语言中不存在执行IN或者OUT指令的方法 这样的调用过程则会增加控制IO的开销​\t\t\t\t1.2 不需要特殊的保护机制来阻止用户进程执行io操作​\t\t\t\t1.3 对于内存映射io 可以引用内存中的每一条指令来引用控制寄存器​\t\t2.缺点：​\t\t\t\t需要禁用高速缓存 减少了响应速度直接存储器存取DMA​\t\t\t为了提高cpu读设备控制器的效率​\t\t\t在cpu和控制器中间加了一层 DMA 他可以调控多个设备的数据传输​\t\t\tDMA使用物理内存地址​\t\t\t在设备控制器和cpu之间加的一层：不让cpu和设备控制器直接打交道 提高cpu读取设备控制器的数据的效率中断​\t中断：​\t\t当硬件完成对应操作 就发出一个中断 通过总线发送到 中断控制器 中断控制器通过对应的中断在中断向量表的值判断 中断是什么设备的中断 再让中断处理程序去做出对应的响应 给 cpu 告诉cpu可以执行其他\t操作了 其中涉及了用户态到内核态到切换 ==用户态和内核态切换具体做了什么事情？==\t1⃣️通过进程的描述符得到 内核栈的相关信息 ss0和esp0\t2⃣️保存用户栈的信息(程序计数器、程序状态字PSW和寄存器) ss0和esp0指向内核栈 cpu将用户栈切换到内核栈 (1次cpu使用)\t3⃣️遍历中断向量表的中断信息 载入寄存器 然后通过中断处理程序执行\t4⃣️再从内核态切换回去 (1次cpu使用)—-合计2次cpu==用户态到内核态消耗了什么 ？==\t1. 频繁的上下文切换 很容易导致 CPU 将大量时间耗费在寄存器、内核栈以及虚拟内存等资源的保存和恢复上，进而大大缩短了真正运行进程的时间。这也正是导致平均负载升高的一个重要因素。\t2.需要管理TLB和cpu的高速缓存 管理其需要cpu的时间片\t3.在有虚拟内存并且必须设置页表或者必须保存MMU状态 IO软件原理程序控制IO用户调用系统调用打印字符首先把字符缓冲区的复制到内核空间的数组中 查看打印机是否可用 不可用就一直等待 直到可用 可用的话就把字符复制到打印机的寄存器中 打印完毕后 切换为用户态这里有个问题就是：输出一个字符后 cpu要不断的查询设备来去了解 它是否就绪接收另一个字符 这种情况称为忙等程序控制IO很简单但是缺点也很明显 直到全部IO完成前要占用cpu的全部时间中断驱动IO每次打印一个字符后 都要等待其打印完毕 每次就浪费了cpu的执行时间 如果把这个等待时间去做别的事情就能提高效率 等到打印机下一次就绪时候再切换回去 执行打印这种情况就叫做 中断驱动IO 每次打印一个字符时候调用一个系统调用 用户态切换到内核态 字符串缓冲区被复制到内核的缓冲区 当打印机把字符打印完毕后 会发出一个中断 表示打印任务做完了cpu可用执行其他任务了 并且要保存当前进程的状态使用DMA的IO让DMA每次给打印机提供一个字符 不用cpu去提供 将中断的次数从每个字符一个减少到每个缓冲区一次IO软件系统层次1.中断处理程序\t让之前被阻塞的驱动程序现在能够被继续运行\t要处理中断后的操作 保存用户栈的上下文 程序计数器 psw 等\t 切换到内核栈2.设备驱动程序\t作用是去控制IO设备 每个驱动设备控制一类的设备 \t接收上方设备无关性软件发出的抽象读写命令序列 并且把它写到控制器的设备寄存器中3.设备无关程序\t为设备驱动程序提供统一的接口\t提供缓冲的功能\t\t无缓冲\t\t用户空间缓冲\t\t内核空间的缓冲\t\t内核空间的双缓冲4.用户IO程序\t如果用户想调用硬件怎么办？通过系统调用实现或者是创建守护线程\t守护线程是一个特殊线程\t打印一个文件的时候 先生成要打印的整个文件 然后把它放到假脱机目录下 由守护线程去打印该目录下的文件 只有该线程能使用打印机 通过保护特殊文件来防止用户直接使用 可用解决某些进程不必要的长期空占打印机的问题在IO软件系统中 数据的读取过程1.用户需要去文件中读取一个块时2.操作系统被调用 来实现这一个请求 3.与设备无关的软件在缓冲区查找要读取的块信息 如果没有则要去使用设备驱动程序区去读取4.在设备驱动程序中 发出命令去让它从磁盘中获取该块 然后进程被阻塞 直到操作完成5.当磁盘操作完成后 硬件产生一个中断 用户态切换到内核态 目的是告诉cpu可用做其他事情了 中断处理程启动处理该中断 通过总线 去中断控制器中的中断向量表中去查询哪个设备发生了什么事情 然后中断处理程序从设备提取状态信息然后唤醒 等待的进程 以此结束此次IO 再从内核态切换回用户态 让等待的进程继续运行" }, { "title": "💎字节跳动夏令营项目 Tiktok", "url": "/posts/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E5%A4%8F%E4%BB%A4%E8%90%A5%E9%A1%B9%E7%9B%AE-TikTok/", "categories": "", "tags": "", "date": "2022-08-13 00:00:00 +0000", "snippet": "💎字节跳动夏令营项目-TikTok ⚙️项目背景⚫此项目是字节跳动夏令营结营大项目 通过讲师所讲的内容 实现一个极简版的抖音 来切实感受 实践课程中学到的知识点 如 常用框架 网络 数据库 操作系统 工业数据结构算法 分布式对象存储 消息队列 以及性能优化 同时 能提升对未来的实际开发工作有更多的深入了解与认识 以及 个人技术成长或视野 ⚙️项目架构 ⚙️项目模块⭐️后端采用主流的M...", "content": "💎字节跳动夏令营项目-TikTok ⚙️项目背景⚫此项目是字节跳动夏令营结营大项目 通过讲师所讲的内容 实现一个极简版的抖音 来切实感受 实践课程中学到的知识点 如 常用框架 网络 数据库 操作系统 工业数据结构算法 分布式对象存储 消息队列 以及性能优化 同时 能提升对未来的实际开发工作有更多的深入了解与认识 以及 个人技术成长或视野 ⚙️项目架构 ⚙️项目模块⭐️后端采用主流的MVC架构1⃣️用户业务模块：⚫登录注册模块(Redis+腾讯云短信+JWT+拦截器)​\t\t用户通过输入手机号+验证码的方式 实现登录、未注册的用户会创建一个新的账号​\t\t6位验证码由后端通过(Math.random() * 9 + 1) * 100000 生成 通过腾讯云的短信服务 发送到对应手机的用户​\t\t为了防止用户暴力登录和非法攻击 使用redis对于同一个IP地址的同一个手机号实现每隔60s才能发送的限制🚫—— redis.setnx60s(MOBILE_SMSCODE+\":\"+ip,ip);​\t\t然后通过写好的 PassportInterceptor 登录拦截器 配合InterceptorConfig(拦截器都要注册进来) 来校验当前ip地址和redis的是否一致 不一致的话抛出异常 一致的话就继续​\t\t 生产的验证码存入redis中——redis.set(MOBILE_SMSCODE+\":\"+mobile(手机号),code(验证码),30*60);​\t\t用户登录成功后会通过JWT生成==Token== 然后用redis将其缓存——redis.set(REDIS_USER_TOKEN+\":\"+users.getId(),JWTtoken);​\t\t最后数据存入MySQL并且把对应的验证码缓存删除 最后返回 对应对象给app​\t\t如果用户退出登录则删除对应redis缓存 redis.del(REDIS_USER_TOKEN+\":\"+userId);​\t\t ⚠️==Tips==:​\t\t\t\t·对BO的字段的样子 通过validation类去验证 同时在接口层架@valid注解开始验证​\t\t\t\t·如果捕获到字段不正确 通过自定义的ExceptionHandler和自定义的Excepition去抛出异常⚫用户信息模块(Redis+MinIO+拦截器)​ ⚫查询个人信息接口​\t\t\t通过传入的用户电话去数据库找 返回一个user对象 然后将其转换为 userVO对象 同时用beanUtils拷贝类的信息 然后对userVO中要展示的粉丝 关注 点赞 属性进行赋值 (通过去Redis\t\t\t中去取对应的用户的粉丝 关注 点赞 值) redis.get(REDIS_MY_XXX_COUNTS + \":\" + userId)「XXX为FANS、FOLLOW、LIKE」;最后返回UserVO对象给前端做渲染​\t ⚫修改个人信息接口:​\t\t通过传入的updateUserBO对象 去数据库覆盖对应的信息 通过前端传入的每一项type判断要修改哪一个选项(tiktok号、姓名、性别、星座、地址···) 最后返回前端修改完成的User对象​ ⚫修改个人头像和背景接口​\t\t\t但点击图片或者背景 通过MinIO的去上传对应图片 指定 MinIO的桶名、文件的名字、file文件流 通过提前写好的MinIO配置类上传文件或者图片到MinIO中​\t\t\t上传完成后获取对应的信息拼接成一个 外部能访问的url地址String url = minIOConfig.getFileHost()+\"/\"+bucketName+\"/\"+filename;​\t\t\t然后构建updateUserBO对象 为其url属性赋值 这里通过前端给的参数判断对象是修改设置头像还是背景的值 然后修改数据同步到Mysql 最后返回对象​\t\t\t其中为这个接口设计的拦截器 UserTokenInterceptor用于去验证 当前本地的用户和token令牌 通过id从redis中拿到了 token值 然后对这个token值进行解压 得到用户id ​\t\t\t如果得到的 用户id和当前的一致的话说明 验证通过拦截器放行 否则抛出异常 此外此拦截器还要注册到对应的InterceptorConfig中去 要去绑定验证的请求路径​ String redisToken = redis.get(REDIS_USER_TOKEN + \":\" + userId);2⃣️粉丝业务模块：⚫关注接口​\t⚫前端传入 用户id和博主id 通过查询用户方法 查看这两个人是否存在数据库 如果存在 则 通过 粉丝service层创建 fans对象 存入数据库中\t​\t\t创建 Fans类 设置主键值(一个工具随机生成)、vlogerId、fansId、互相关注字段(通过一个方法查看当前用户的粉丝列表是否有博主 如果有那么两者的互粉字段设置为1)​\t\t数据插入MySQL​ ⚫ 再用Redis存入 对应的关注数量 粉丝数量 以及粉丝和博主的关系 加快查询速度​\t\t我关注了一个人 我的关注➕1 —— redis.increment (REDIS_MY_FOLLOWS_COUNTS+\":\"+myId,1);​\t\t博主被关注 博主的粉丝➕1 —— redis.increment (REDIS_MY_FANS_COUNTS+\":\"+vlogerId,1);​\t\t设置一个键表示 粉丝和博主的关系⚛️ —— redis.set(REDIS_FANS_AND_VLOGGER_RELATIONSHIP+\":\"+myId+\":\"+vlogerId,\"1\");​\t⚫当关注一个人成功后 使用MongoDB创建一个msgMO对象(包括发送者的id、发送者的昵称、发送者的头像、消息的内容、消息类型、接受者的id、消息的创建时间)发送到MongoDB中​⚫取消关注接口​\t⚫前端传入粉丝id和博主id 去查询 Fans表 先查看博主的粉丝列表 查看博主是否关注了我 如果关注了我 并且互粉状态为1 那么 就要 再去查看我是的粉丝是否有博主 如果有 把我的粉丝(博主)的互粉字段 设置为0 把我的粉丝(博主)更新到数据库 然后再从 博主的粉丝列表 删除我 让我不是他的粉丝​\t⚫接着在Redis中把我的 关注数量 博主的粉丝数 以及 粉丝和博主的关系 设置设置为自减1⚫我的关注接口​\t⚫通过myID去数据库 进行查询 -通过fans表和user表 去查询对应的信息 然后分页表示出来​\t对应的SQL语句SELECT\tu.id AS vlogerId,\tu.face AS face,\tu.nickname AS nickname FROM fans fLEFT JOIN users u ON f.vloger_id = u.id WHERE f.fan_id = 1 ORDER BY u.nicknameASC ⚫我的粉丝列表接口​\t⚫通过传入的myId去数据库 进行查询 -通过fans表和user表 去查询对应的信息 然后分页表示出来SQL语句SELECT\tu.id AS vlogerId,\tu.face AS face,\tu.nickname AS nickname FROM fans fLEFT JOIN users u ON f.fans_id = u.id WHERE f.vlogerId = xxx ORDER BY u.nicknameASC3⃣️视频业务模块:⚫上传视频接口​\t\t⚫由前端上传到uni_cloud的OSS中 然后返回 一个vlogBo对象 再把vlogBo 通过beanUtil工具类进行值的拷贝 最后存入MySQL数据库⚫推荐列表接口​\t\t⚫前端传入 用户id和搜索的关键词​\t\t⚫通过数据库 用户表和视频表的关联查询 vlog.vloger.id = u.id 并且 is_private是0 也就是公开的视频 并且 视频的titile = 传入的keyword 按照 创建时间的倒叙排列​\t\t⚠️ 此处的使用了 like = \"%xxxx%\"方式去模糊查询 但是设置的索引会失效 可以使用ES去优化查询速度 ​\t\t⚫最后返回查询的视频列表⚫获取视频详情接口​\t\t⚫前端传入 视频的id 以及 用户id 通过视频id 作为条件 让用户表和视频表的关联查询 vlog.vloger.id = user.id 条件是 vlog id = 传入视频id 返回对应的一条视频详情 返回前端⚫设为私密视频接口​\t\t⚫前端传入 视频的id 以及 用户id 通过视频id 作为条件 再把vlog的is_private设置为1(表示私密) 构成一个新的vlog对象 去数据库中更新对于对象⚫设为公开视频接口​\t\t⚫前端传入 视频的id 以及 用户id 通过视频id 作为条件 再把vlog的is_private设置为0(表示公开) 构成一个新的vlog对象 去数据库中更新对于对象⚫我的私密视频​\t\t⚫前端传入 用户id 和 视频vlog的is_private为1(表示私密) 作为条件 构成一个新的vlog对象 去vlog表中数据库中查找vlog集合 并且 分页返回⚫我的公开视频​\t\t⚫前端传入 用户id 和 视频vlog的is_private为0(表示公开) 作为条件 构成一个新的vlog对象 去vlog表中数据库中查找vlog集合 并且 分页返回⚫点赞视频操作(对点赞表操作)​\t\t⚫通过 用户id和视频id 为条件 以及生成的主键ID 构建一个LikeVlog类 用于对应数据库中的表 然后将其插入MySQL 即可完成点赞​\t\t⚫点赞完成后 还有构建一个msgMO对象(包含发送信息用户、接受信息用户以及视频的相关信息) 存入MongoDB完成消息提醒功能​\t\t⚫之后 因为视频点赞数 以及 用户是否喜欢 某视频的关系 可以通过Redis去记录这些数字信息​\t\t\t ·点赞了一个视频就 让点赞数 自增1redis.increment(REDIS_VLOG_BE_LIKED_COUNTS+\":\"+vlogId,1);​\t\t\t ·点赞了表示用户喜欢某个视频 redis.set(REDIS_USER_LIKE_VLOG+\":\"+userId+\":\"+vlogId,\"1\");⚫取消视频操作​\t\t⚫通过 用户id和视频id 为条件 以及生成的主键ID 构建一个LikeVlog类 用于对应数据库中的表 然后将其删除MySQL 即可完成取消点赞点赞​\t​\t\t⚫之后 因为视频点赞数 也存在于Redis中 故redis也要做同步的删除​\t\t\t ·取消点赞了一个视频就 让点赞数 自减1redis.increment(REDIS_VLOG_BE_LIKED_COUNTS+\":\"+vlogId,1);​\t\t\t ·取消 点赞了 表示用户不喜欢某个视频 把代表其关系的key做一个删除 redis.del(REDIS_USER_LIKE_VLOG+\":\"+userId+\":\"+vlogId);⚫我的点赞视频列表​\t\t⚫通过用户id去数据库中查询 myLike和vlog表 做关联v.id = mlv.vlog_id 并且视频是公开的 获取对应视频列表 然后返回队友点赞List⚫关注的人视频列表​\t\t⚫通过 用户id 去表vlog 和 fans 表 中做关联查询 v.通过用户id去找到对应关注的博主 然后 通过博主 id去vlog表中找 其发表的视频列表信息 并且视频必须是公开的⚫我的朋友视频列表​\t\t⚫通过 用户id 去表vlog 和 fans 表 中做关联查询 v.通过用户id去找到对应关注的博主 双方要是互关的状态 然后 通过博主的id去vlog表中找 其发表的视频列表信息 并且视频必须是公开的4⃣️评论业务模块:⚫创建评论​\t⚫前端传入CommentBO对象 然后对将其设置id 时间 将其转化为 Comment对象 再将其插入MySQL评论表中​\tredis中添加一个字段 表示某个视频被点赞的次数 用于前端的快速获取redis.increment(REDIS_VLOG_COMMENT_COUNTS+\":\"+commentBO.getVlogId(),1); \t​\t ⚫添加完评论后要通知 被评论的视频博主 使用MongoDB先构建msgMO对象(设置发送人信息、接受者信息、发送的具体消息、消息类型[评论消息、还是回复评论消息]) 入库⚫获取评论​\t⚫从redis中获取某视频的评论数量 再返回 不用去数据库去统计 缓存了评论的数量​\t⚫通过 视频id 去 评论表中 找出对应视频的列表commentList 然后 把映射成commentVoList 对每一个 commentVo都要设置 视频被点赞的数量 以及视频被评论的总数去redis获取 作为​\t视图层的Comment对象⚫删除评论​\t⚫前端传入 commentId、评论者id、评论的视频id​\t⚫通过commentId和评论者id作为一个对象 删除对应的评论​\t⚫然后还要去redis中减少一条评论的数量 redis.decrement(REDIS_VLOG_COMMENT_COUNTS+\":\"+vlogId,1);⚫点赞评论​\t⚫纯redis操作 不需要用到 mysql 只需要知道是那条评论和哪个人就行了​\t⚫如果点赞了一条评论 首先要会构建一条消息发送给MongoDB ​\t⚫通过评论id可以拿到 评论 以及 博主id 从而得到视频的信息​\t⚫然后构建一个msgMO对象 发送到 mongoDB 完成的对视频评论的点赞消息 入库​\t⚫之后还要对redis中 某条评论的评论数量自增1​\tredis.increment(REDIS_VLOG_COMMENT_LIKED_COUNTS+\":\"+commentId,1);​\t⚫以及某人点赞了某个视频的关系 设置一个key​\tredis.set(REDIS_USER_LIKE_COMMENT+\":\"+userId+\":\"+commentId,\"1\");⚫取消点赞评论​\t⚫对redis中某条评论的评论数量数自减1​\tredis.dcrement(REDIS_VLOG_COMMENT_LIKED_COUNTS+\":\"+commentId,1);​\t⚫以及某人点赞了某个视频的关系 删除代表关系的这个key​\tredis.del(REDIS_USER_LIKE_COMMENT+\":\"+userId+\":\"+commentId);5⃣️消息业务模块⚫消息的创建​\t⚫通过构建一个msgMO的对象​\t\t\t消息的发送者、接受者、消息类型、消息的内容、发送者昵称、发送者的头像和消息的发送时间 最后存入MongoDB⚫消息的获取​\t\t\t⚫前端传过来的用户id作为 toUserID 去查询所有消息 ⚙️技术选型⭐️前后端分离架构1⃣️前端：Uni_App、Uni_Cloud、Vue、Html、Css2⃣️后端：Java3⃣️框架:\tSpringMVC、SpringBoot、MyBatis4⃣️数据库:\tMySQL5⃣️中间件:\tRedis、MongoDB、RabbitMQ、MinIO、Nginx、ELK6⃣️DevOps:\tGit、Maven、Linux ⚙️项目优化1⃣️网络⚫CDN加速⏩:​\t\t⚫起因:用户加载视频的时间长 app的整体体验感不好​\t\t⚫解决:使用阿里云的CDN加速 将app视频分发至全球各地最接近用户的节点 缩短用户到节点的物理距离,使用户可就近取得所需内容,降低延迟⚫Nginx反向代理⏩:​\t\t⚫起因:当用户访问量高的时候 造成单结点的服务器的压力很大​\t\t⚫解决:使用Nginx的反向代理技术和负载均衡策略 app部署在不同的云服务器上 通过统一的域名进入 Nginx则对请求进行分发 减轻了服务器的压力 提高了系统的吞吐量​\t\t⚫效果:使用Jmeter对评论接口进行了测试 在服务器测试 开启Nginx和不开启Nginx的效果 在5k流量下 ==性能提升效果提升显著 平均响应时间降低64% 吞吐量提升5倍== 2⃣️后端：⚫RabbitMQ异步解耦​\t\t⚫起因: 由于每次进行点赞视频、关注用户、评论视频操作后都需要 把对应的信息发送到MongoDB 即在处理核心数据的后面同步的处理非核心的数据 如果此操作出现问题的话 那么会影响核心数据的处理 让整条调用链瘫痪 模块间会互相影响 从而增加了调用链长度 导致用户操作的时候得到的反馈和速度都不佳​\t\t⚫解决:使用消息中间件把同步调用改为异步调用 同时降低消息模块和其他模块之间的耦合度 具体采用RabbitMQ消息队列​\t\t⚫效果:使用Jmeter对接口进行了测试 在服务器测试 开启和不开启RabbitMQ的效果 在1w流量下 ==性能提升效果为 平均响应时间降低18% 吞吐量提升约2倍==⚫MinIO分布式存储​\t\t⚫起因:传统的单机架构下 视频等静态资源都是放在服务器本地 当用户数量很多的时候 视频的存储是一个很大问题 造成单个的服务器的存储压力很大 所以需要找到一个 海量存储 简单易用和便宜的存储系统 适合计算中间结果的服务器 ​\t\t⚫解决:使用MinIO进行分布式等对象存储 对象存储具有EB级别的海量存储 对象的数量不受限制 基于Restful 的http接口 简单易用 使用普通的x86服务器 租用便宜 具体流程是把用户上传的视频上传至MinIO服务器 后续访问静态资源的时候 只需要访问MinIO共享share出来的url就行了 减轻了服务器的压力 提高了系统性能3⃣️数据:⚫MySQL索引查询优化​\t\t⚫起因:为了提高查询的响应速度 提升查询的效率 提升用户体验​\t\t⚫解决:在表的连接处或者where条件中 建立MySQL的索引 配合 Explain关键字 查看是否该查询走了索引​\t\t⚫效果:使用进行了对比测试 查看是否走了索引⚫Redis缓存热点数据​\t\t⚫起因:为了加快数据的响应 对数字的操作和存储 以及常用的数据 可以使用Redis进行缓存​\t\t\t\t1.登录接口:​\t\t\t\t\t缓存ip地址 设置失效时间60s​\t\t\t\t\t缓存验证码 失效时间 3*60s​\t\t\t\t\t缓存Token 解决分布式Session问题​\t\t\t\t2.个人信息接口​\t\t\t\t\t缓存 用户的关注数 用户的粉丝数 以及获赞数​\t\t\t\t3.粉丝接口​\t\t\t\t\t用户关注博主 缓存 用户关注数+1、博主粉丝数+1、表示用户关注博主的键设置为1​\t\t\t\t\t用户取关博主 缓存 用户关注数-1、博主粉丝数-1、删除 表示用户关注博主的关系键​\t\t\t\t4.视频接口​\t\t\t\t\t视频被某人点赞 缓存 视频的被点赞数量 还有 表示拥护点赞了某条视频的键表示 两者有关系​\t\t\t\t\t视频被某人取消点赞 删除缓存 减少视频的被点赞数量 还有 删除 表示拥护点赞了某条视频的键​\t\t\t\t5.评论接口​\t\t\t\t\t视频被评论 缓存 视频被评论的数量+1 ​\t\t\t\t\t视频评论被删除 缓存 视频被评论的数量-1​\t\t\t\t6.评论点赞​\t\t\t\t\t视频的评论被点赞 缓存 评论被点赞的数量+1 以及 添加 代表视频评论被某人点赞的关系的键​\t\t\t\t\t视频的评论取消点赞 缓存 评论被点赞的数量-1 以及 删除代表视频评论被某人点赞的关系的键​\t\t⚫解决:使用Redis进行缓存⚫ELK数据查询优化​\t\t⚫起因:为了加快响应全文搜索等速度 由于全文搜索是对视频的titile和content做模糊查询like %xxx% 不能用索引去优化 因为会导致索引失效​\t\t⚫解决:使用ElasticSeach+Logstash+Kibana+IK分词器 先用logstash 把数据库数据同步到es中 再对es执行搜索 采用ik分词技术 利用es的倒排索引 提高了视频的查询速度​\t\t⚫效果:使用Jmeter对接口进行对比测试 ⚙️项目部署1⃣️采用宝塔可视化UI➕阿里云项目部署上线2⃣️项目GitHub地址:https://github.com/Zhangz1w3nBeatbox/TikTok3⃣️项目安卓端演示地址:http://106.14.35.137:9000/tiktok/TikTok.apk" }, { "title": "💎并发编程_volatile", "url": "/posts/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_Volatile/", "categories": "", "tags": "", "date": "2022-07-17 00:00:00 +0000", "snippet": "volatile1.可见性​\t\t原理：X86处理器下:带volatie的变量 翻译成汇编码是:lock addl.. 意思是在寄存器上进行一个空操作​\t\t\t 实现可见性的关键是lock前缀!在多核处理器下lock前缀会做两件事​\t\t\t\t \t1.把更新的值推送到主存​\t\t\t\t\t\t\tlock信号保证在处理期间 锁定这块内存的缓存行 并且写回主存 然后使用缓存一致性协议来保证修改的...", "content": "volatile1.可见性​\t\t原理：X86处理器下:带volatie的变量 翻译成汇编码是:lock addl.. 意思是在寄存器上进行一个空操作​\t\t\t 实现可见性的关键是lock前缀!在多核处理器下lock前缀会做两件事​\t\t\t\t \t1.把更新的值推送到主存​\t\t\t\t\t\t\tlock信号保证在处理期间 锁定这块内存的缓存行 并且写回主存 然后使用缓存一致性协议来保证修改的\t\t\t\t\t\t\t原子性 缓存一致性协议会阻止同时修改两个以上的缓存行​\t\t\t\t\t 2.致其他缓存了该变量的缓存行无效​\t\t\t\t\t\t\t在缓存一致性协议的下 其他处理器会通过cpu的嗅探技术 查看自己的内存的缓存行的数据是否被修改​\t\t\t\t\t\t\t如果是则致缓存行无效2.有序性(防止重排序)​\t\t·为什么出现指令重排序？-为了提高性能​\t\t·重排的分类:​\t\t\t1.编译器:在不改变单线程程序语义情况下 可以重排序​\t\t\t\t对于编译器重排JMM的编译器重排规则会禁止某些重排序\t\t​\t\t\t2.处理器:数据间不存在依赖性则可以重排序​\t\t\t\t对于处理器重排 通过加入内存屏障来实现重排序​\t\t\t\t\t内存屏障:​\t\t\t\t\t\t\tStore Store Barriers:写-写不能重排序​\t\t\t\t\t\t\tStore Load Barriers:写-读不能重排序​\t\t\t\t\t\t\tLoad Load Barriers:读-读不能重排序​\t\t\t\t\t\t\tLoad Store Barriers:读-写不能重排序​\t\t\t·happens-before规则​\t\t\t\t\t\t·线程内的所以操作都happens-before后续操作​\t\t\t\t\t\t·锁的释放happens-before 随后对这个对象的加锁​\t\t\t\t\t\t·volatile变量的写 happens-before 在volatile 的读​\t\t\t\t\t\t·A happens-before B — B happens-before C –&gt; A happens-before C\t\t\t\t​ ·as-if-serial原则:​\t\t\t\t 不管怎么重排都不会对有数据依赖的操作重新排序​\t\t\t happens-before和as-if-serial本质是一回事​\t\t\t\t as-if-serial：保证单线程内程序的结果不变 happens-before：保证正确的同步的多线程程序执行结果不变​\t\t\t\t as-if-serial：单线程下程序看似是顺序执行的 happens-before：正确同步的多线程下程序看似是顺序执行的​\t\t\tvolatile写:加Store Store Barriers 和Store Load Barriers:写-读不能重排序​\t\t\tvolatile读:加Load Load Barriers 和Load Store Barriers:写-读不能重排序​\t\t\t应用:单例模式下的DCL为什么用volatile关键字?​\t\t\t\t原因：​\t\t\t\t\t\t1.创建对象分三步: \t​\t\t\t\t\t\t\t\t开辟内存空间 赋默认值​\t\t\t\t\t\t\t\t调用构造 函数赋初始值​\t\t\t\t\t\t\t\t栈中的变量的引用指向堆中的地址​\t\t\t\t\t\t2.其中第二步和第三步在多线程的情况下 可能重排序 导致得到一个未初始化完全的对象​\t\t\t\t\t\t3.加了volatile关键字 会在 new instance 前加 Store Store屏障 在 其后加Store Load屏障 ​\t\t\t\t\t\t\t 保证volatile写 完后才能读//DCL单例public class sigeton{ private static volatile sigeton sgt; private sigeton(){}; public sigeton getInstance(){ \tif(sgt==null){ synchronized(this){ if(sgt==null){ \t\tsgt = new sigeton(); \t} } } return sgt; } }\t\t\t\t\t\t\t\t3.原子性:​\t只能保证单一变量的原子性" }, { "title": "💎并发编程_synchronized", "url": "/posts/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_Synchronized/", "categories": "", "tags": "", "date": "2022-07-17 00:00:00 +0000", "snippet": "Synchronized1.使用:·同步方法\t\tJVM源码：在class类文件中的访问标识符中 标识为 ACC_SYNCHRONIZED\t\t普通方法-锁的当前对象\t\t静态方法-锁的是当前类.class·同步代码块\t\t原理：\t\t从monitor-entry进入 再从monitor-exit出来一个正常出口和一个异常出口\t\t线程执行到monitor-entry指令后 尝试获取对象对应的monit...", "content": "Synchronized1.使用:·同步方法\t\tJVM源码：在class类文件中的访问标识符中 标识为 ACC_SYNCHRONIZED\t\t普通方法-锁的当前对象\t\t静态方法-锁的是当前类.class·同步代码块\t\t原理：\t\t从monitor-entry进入 再从monitor-exit出来一个正常出口和一个异常出口\t\t线程执行到monitor-entry指令后 尝试获取对象对应的monitor所有权 \t\tJVM中每个对象都会有一个'监视器'，监视器和对象一起创建、销毁。监视器相当于一个用来监视这些线程进入的特殊房间，其义务是保证（同一时间）只有一个线程可以访问被保护的临界区代码块\t\t·Hotspot虚拟机中，监视器是由C++类ObjectMonitor实现的\t\t\t组成：Cxq：竞争队列(Contention Queue),所有请求锁的线程首先被放在这个竞争队列中\t\t\t\t EntryList：Cxq中那些有资格成为候选资源的线程被移动到EntryList中 WaitSet：拥有Monitor的线程在调用wait()方法之后将被阻塞然后该线程将被放置在WaitSet中\t\t\t\t owner：获得到minitor的对象会进入owner2.原理:·对象：\t1.对象头\t\t\t1.1：Mark-Word(32位):存储锁的信息、GC信息\t\t\t\t\t无锁状态: hashcode(25位)、 分代年龄(4位)、偏向位(1位)[0]、锁标记位(2位)[01]\t\t\t\t\t偏向锁态: 线程id(23位)、epoch(2位)、分代年龄(4位)、偏向位(1位)[1]、锁标记位(2位)[01]\t\t\t\t\t轻量级锁: 指向栈中锁记录的指针(30位)、\t\t\t 锁标记位(2位)[00]\t\t\t\t\t重量级锁: 指向重量级锁的指针(30位)、\t\t\t 锁标记位(2位)[10]\t\t\t 1.2：ClassPoint(32位) \t\t\t1.3：数组长度(如果是数组对象)\t\t\t2.实例数据\t3.填充3.锁升级:1.无锁状态: 普通对象👇👇👇👇👇2.偏向锁态:(无线程竞争锁)\t\t-获取偏向锁大多数情况下 锁不存在竞争并且总是由一个线程多次获取 为了让线程获得所得代价更低 就引入偏向\t\t 锁让线程访问同步代码块得到锁后 会在对象头和栈帧的锁记录中存储偏向锁的线程ID \t\t-再次获取偏向锁：获取锁时只需要看MarkWord中是否存在 当前线程的偏向锁 存在的话 说明是同一个线程获取锁 \t\t\t如果不存在 则再看MarkWord中偏向锁的标识是否设置为1 如果有则用cas把对象头的偏向锁指向当前线程 如果\t\t\t没有则使用cas竞争\t\t-释放偏向锁：当出现锁的竞争的时候 就要撤销 撤销时要等到全局的安全点(此时无执行的字节码文件) 暂停拥有的偏向锁线程 然后检查拥有的偏向锁线程是否存活 不是存活状态 则设置为 ‘无锁状态’ 是存活状态 拥有偏向锁的栈会被执行 遍历偏向锁对象的锁记录 栈中的锁记录 和对象头的markword 要么重新偏向与其他线程 要么恢复到 无锁或者标记对象不合适作为偏向锁 最后唤醒暂停线程\t\t-java6、7默认开启偏向锁 只不过要等待几秒钟才能启动 如果明确有锁竞争 则可以关闭偏向锁 直接进入轻量级锁👇👇👇👇👇3.轻量级锁:\t\t-轻量级锁的加锁：\t\t\t先撤销偏向锁\t\t\t在执行同步代码块前 在当前线程的栈的栈帧中 创建锁记录 然后把对象头中的markword复制到 锁记录中\t\t\t然后用cas将对象头中的markword替换成指向所记录的指针 如果成功则表示获取到锁 否则表示其他锁竞争\t\t-轻量级锁的解锁：\t\t\t用cas把锁记录的markword信息复制到对象头的markword中 -升级为重量级锁：当自旋次数超过 10次或者线程数超过cpu核数的一半 👇👇👇👇👇\t4.重量级锁:\t\t处于重量级锁状态下 没获取到锁的线程 会被阻塞 进入阻塞队列 线程挂起 不占用cpu资源\t\t·重量级锁的原理：JVM中每个对象都会有一个'监视器'，监视器和对象一起创建、销毁。监视器相当于一个用来监视这些线程进入的特殊房间，其义务是保证（同一时间）只有一个线程可以访问被保护的临界区代码块\t\t·Hotspot虚拟机中，监视器是由C++类ObjectMonitor实现的\t\t\t组成：Cxq：竞争队列(Contention Queue),所有请求锁的线程首先被放在这个竞争队列中\t\t\t\t EntryList：Cxq中那些有资格成为候选资源的线程被移动到EntryList中 WaitSet：某个拥有ObjectMonitor的线程在调用Object.wait()方法之后将被阻塞，然后该线程将被放置在WaitSet链表中\t\t\t\t 获得到minitor的对象会进入owner\t\t·重量级锁会发生线程的上下文切换，从用户态切换到内核态。系统调用是内核态为用户态进程提供的Linux内核态下互斥锁的访问机制，系统调用就会从用户态切换到内核态，这种切换是需要消耗很多时间的，而JVM重量级锁使用了Linux内核态下的互斥锁mutex。 ![1657965926287](C:\\Users\\User\\AppData\\Roaming\\Typora\\typora-user-images\\1657965926287.png)4.锁之间的比较偏向锁：\t\t\t适合只有一个线程访问同步代码块 加锁解锁不要耗费资源\t\t\t但是 如果存在多个线程的锁竞争则会带开 偏向锁撤销的消耗轻量级锁：\t\t\t适合追求响应比的场景 同步代码块执行速度很快 线程不会阻塞\t\t\t但是 如果始终得不到锁竞争的线程 则会空耗cpu资源重量级锁：\t\t\t适合吞吐量高的场景 同步代码块时间长 线程之间竞争不自选 而是挂起 不耗费资源\t\t\t但是 线程会阻塞 等待时间长 响应比低5.CAS和Synchronized的区别1.加锁的开销：死锁 加锁 解锁 线程切换 内核态到用户态的切换 线程阻塞等待时间长--追求吞吐量2.CAS的空循环占cpu资源 线程不会阻塞 --追求相应比重量级锁图" }, { "title": "题型归类🔍_模拟问题 字符串", "url": "/posts/%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB-_%E6%A8%A1%E6%8B%9F%E9%97%AE%E9%A2%98-%E5%AD%97%E7%AC%A6%E4%B8%B2/", "categories": "", "tags": "", "date": "2022-07-16 00:00:00 +0000", "snippet": "1️⃣.字符串相乘class Solution { //模拟-字符串 public String multiply(String s1, String s2) { if(s1.equals(\"0\")||s2.equals(\"0\")) return \"0\"; int len1 = s1.length(); int len2 = s2.len...", "content": "1️⃣.字符串相乘class Solution { //模拟-字符串 public String multiply(String s1, String s2) { if(s1.equals(\"0\")||s2.equals(\"0\")) return \"0\"; int len1 = s1.length(); int len2 = s2.length(); int[] temp = new int[len1+len2]; for( int i=len1-1;i&gt;=0;--i){ for(int j=len2-1;j&gt;=0;--j){ int n1 = s1.charAt(i)-'0'; int n2 = s2.charAt(j)-'0'; int sum = n1*n2+temp[i+j+1]; int div = sum/10; int mod = sum%10; temp[i+j+1]=mod; temp[i+j]+=div; } } StringBuffer sb = new StringBuffer(); for(int i=0;i&lt;temp.length;++i){ if(i==0&amp;&amp;temp[i]==0) continue; sb.append(temp[i]); } return sb.toString(); }}2️⃣.字符串相加(十进制)class Solution { //模拟-字符串 public String addStrings(String s1, String s2) { int len1 = s1.length(); int len2 = s2.length(); int i=len1-1; int j=len2-1; int add=0; StringBuffer sb = new StringBuffer(); while(i&gt;=0||j&gt;=0||add!=0){ int n1 =i&gt;=0?s1.charAt(i)-'0':0; int n2 =j&gt;=0?s2.charAt(j)-'0':0; int sum = n1+n2+add; int div = sum/10; int mod = sum%10; add = div; sb.append(mod); --i; --j; } return sb.reverse().toString(); }}3️⃣.字符串相加(三十六进制)class Solution { //模拟-字符串 public String add36Strings(String s1, String s2) { int len1 = s1.length(); int len2 = s2.length(); int i=len1-1; int j=len2-1; int add=0; StringBuffer sb = new StringBuffer(); while(i&gt;=0||j&gt;=0||add!=0){ int n1 =i&gt;=0?getInt(s1.charAt(i)):0; int n2 =j&gt;=0?getInt(s2.charAt(j)):0; int sum = n1+n2+add; int div = sum/36; int mod = sum%36; add = div; sb.append(getChar(mod)); --i; --j; } return sb.reverse().toString(); } \t//字符 转化成 整数\tpublic int getInt(char c){ \tif ('0' &lt;= c &amp;&amp; c &lt;= '9'){//字符是 0-9 则正常 c-'0'; \treturn c-'0'; }else{//字符是 a-z 则正常 c-'a'+10; \treturn c-'a'+10; } \t} //整数 转化成 字符 public char getChar(int n){ \tif(n&lt;=9){ \treturn (char)(n+'0'); \t}else{ \treturn (char)(n-10+'a');\t\t}\t} }总结提炼🎯 " }, { "title": "题型归类🔍_零钱兑换系列", "url": "/posts/%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB-_%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%E7%B3%BB%E5%88%97/", "categories": "", "tags": "", "date": "2022-06-12 00:00:00 +0000", "snippet": "1️⃣.零钱兑换I 题目:可以凑成总金额所需的最少的硬币个数class Solution { public int coinChange(int[] coins, int amount) { int[] dp = new int[amount+1]; Arrays.fill(dp,amount+1); dp[0]=0; for(...", "content": "1️⃣.零钱兑换I 题目:可以凑成总金额所需的最少的硬币个数class Solution { public int coinChange(int[] coins, int amount) { int[] dp = new int[amount+1]; Arrays.fill(dp,amount+1); dp[0]=0; for(int i=1;i&lt;=amount;++i){ for(int j=0;j&lt;coins.length;++j){ if(i&gt;=coins[j]){ dp[i]=Math.min(dp[i],dp[i-coins[j]]+1); } } } return dp[amount]!=amount+1?dp[amount]:-1; }}2️⃣.零钱兑换II 题目:请你计算并返回可以凑成总金额的硬币组合数class Solution { public int change(int amount, int[] coins) { int[]dp=new int[amount+1]; dp[0]=1; for(int co:coins){ for(int i=co;i&lt;=amount;++i){ dp[i]+=dp[i-co]; } } return dp[amount]; }}2.总结提炼🎯 " }, { "title": "题型归类🔍_计算器", "url": "/posts/%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB-_%E8%AE%A1%E7%AE%97%E5%99%A8/", "categories": "", "tags": "", "date": "2022-05-16 00:00:00 +0000", "snippet": "1️⃣.基本计数器(带括号)class Solution { public int calculate(String s) { int len = s.length(); int sign = 1; int res=0; Deque&lt;Integer&gt; stack = new LinkedList();//stakc 存...", "content": "1️⃣.基本计数器(带括号)class Solution { public int calculate(String s) { int len = s.length(); int sign = 1; int res=0; Deque&lt;Integer&gt; stack = new LinkedList();//stakc 存操作符号 stack.push(1); int l=0; while(l&lt;len){ char c = s.charAt(l); if(c==' '){ ++l; }else if(c=='+'){ sign = stack.peek(); ++l; }else if(c=='-'){ sign = -stack.peek(); ++l; }else if(c=='('){ stack.push(sign); ++l; }else if(c==')'){ stack.pop();//** */ ++l; }else{ int num=0; while(l&lt;len&amp;&amp;Character.isDigit(s.charAt(l))){ num = 10*num+s.charAt(l)-'0'; ++l; } res+=num*sign;//** */ } } return res; }}2️⃣.基本计数器(带乘除)class Solution { //计算器-带乘除-栈存的是操作数 public int calculate(String s) { int len = s.length(); int carr=0; char sign ='+'; Deque&lt;Integer&gt; stack = new LinkedList(); for(int i=0;i&lt;len;++i){ char c = s.charAt(i); //遍历到的字符是数字 if(c&gt;='0'){ carr =10*carr+c-'0'; } //遍历到的字符是操作符号 if(c&lt;'0'&amp;&amp;c!=' '||i==len-1){ if(sign=='+'){ stack.push(carr); }else if(sign=='-'){ stack.push(-carr); }else if(sign=='*'||sign=='/'){ int temp = sign=='*'?stack.pop()*carr:stack.pop()/carr; stack.push(temp); } carr=0; sign=c; } } int res=0; while(!stack.isEmpty()){ res+=stack.pop(); } return res; }}总结提炼🎯 1️⃣要舍得用指针" }, { "title": "题型归类🔍_链表反转", "url": "/posts/%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB-_%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC/", "categories": "", "tags": "", "date": "2022-05-05 00:00:00 +0000", "snippet": "1️⃣.从头到尾的链表反转class Solution { public ListNode reverseList(ListNode head) { ListNode pre =null; ListNode curr = head; while(curr!=null){ ListNode next = curr.next;...", "content": "1️⃣.从头到尾的链表反转class Solution { public ListNode reverseList(ListNode head) { ListNode pre =null; ListNode curr = head; while(curr!=null){ ListNode next = curr.next; curr.next = pre; pre = curr; curr = next; } return pre; }}2️⃣.给定区间的链表反转class Solution { public ListNode reverseBetween(ListNode head, int left, int right) { ListNode temp = new ListNode(0,head); ListNode pre =temp; \t\t//找到要反转节点 前面那个节点 int r=1; while(r&lt;left){ pre = pre.next; ++r; } ListNode curr = pre.next; for(int i=1;i&lt;=right-left;++i){ ListNode next = curr.next; curr.next = next.next; next.next = pre.next; pre.next = next; } return temp.next; }}3️⃣. 2个一组的链表反转class Solution { //两个一组反转链表 public ListNode swapPairs(ListNode head) { ListNode pre = new ListNode(0,head); ListNode temp = pre; while(pre.next!=null&amp;&amp;pre.next.next!=null){ ListNode n1 = pre.next; ListNode n2 = pre.next.next; pre.next = n2; n1.next = n2.next; n2.next = n1; pre = n1; } return temp.next; }}4️⃣. k个一组的链表反转class Solution { //k个一组反转链表 public ListNode reverseKGroup(ListNode head, int k) { ListNode temp = new ListNode(0,head); ListNode end = temp; ListNode pre = temp; while(end.next!=null){ for(int i=1;i&lt;=k&amp;&amp;end!=null;i++){ end =end.next; } if(end==null) break; ListNode start = pre.next; ListNode next = end.next; end.next=null; pre.next = reverse(start); start.next =next; pre =start; end =pre; } return temp.next; } public ListNode reverse(ListNode head){ ListNode pre = null; ListNode curr = head; while(curr!=null){ ListNode next = curr.next; curr.next = pre; pre=curr; curr=next; } return pre; }}总结提炼🎯 1️⃣要舍得用指针" }, { "title": "题型归类🔍_股票问题", "url": "/posts/%E9%A2%98%E5%9E%8B%E5%BD%92%E7%B1%BB-_%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/", "categories": "", "tags": "", "date": "2022-04-20 00:00:00 +0000", "snippet": "1️⃣.买卖股票I\t//给定一个数组 prices 它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格 你只能选择 某一天 买入这只股票 并选择在 未来的某一个不同的日子 卖出该股票 设计一个算法来计算你所能获取的最大利润返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润 返回 0class Solution { public int maxProfit...", "content": "1️⃣.买卖股票I\t//给定一个数组 prices 它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格 你只能选择 某一天 买入这只股票 并选择在 未来的某一个不同的日子 卖出该股票 设计一个算法来计算你所能获取的最大利润返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润 返回 0class Solution { public int maxProfit(int[] prices) { int maxProfit=0; int minPrice =Integer.MAX_VALUE; for (int i = 0; i &lt;prices.length ; i++) { if(minPrice&gt;prices[i]){ minPrice = prices[i]; } if(maxProfit&lt;prices[i]-minPrice){ maxProfit = prices[i]-minPrice; } } return maxProfit;\t}}2️⃣.买卖股票II//给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。在每一天，你可以决定是否购买和/或出售股票。你在任何时候最多只能持有一股股票。你也可以先购买，然后在同一天 出售。返回你能获得的最大利润class Solution { public int maxProfit(int[] nums) { int len = nums.length; int ans =0; for(int i=1;i&lt;len;i++){ if(nums[i]&gt;nums[i-1]){ ans+=nums[i]-nums[i-1]; } } return ans; }}3️⃣.买卖股票III//给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。class Solution { public int maxProfit(int[] prices) { int fstBuy = Integer.MIN_VALUE, fstSell = 0; int secBuy = Integer.MIN_VALUE, secSell = 0; for(int p : prices) { fstBuy = Math.max(fstBuy, -p); fstSell = Math.max(fstSell, fstBuy + p); secBuy = Math.max(secBuy, fstSell - p); secSell = Math.max(secSell, secBuy + p); } return secSell; }}4️⃣.买卖股票IV//给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）class Solution { public int maxProfit(int k, int[] prices) { int[] buy = new int[k+1]; int[] sale = new int[k+1]; Arrays.fill(buy,Integer.MIN_VALUE); Arrays.fill(sale,0); for(int p:prices){ for(int i=1;i&lt;=k;++i){ buy[i] = Math.max(buy[i],sale[i-1]-p); sale[i] = Math.max(sale[i],buy[i]+p); } } return sale[k]; }}5️⃣.买卖股票(有冷冻期)//给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）class Solution { public int maxProfit(int[] nums) { int[][] dp = new int[3][nums.length]; dp[0][0]=-nums[0]; for(int i=1;i&lt;nums.length;++i){ //有股 dp[0][i]=Math.max(dp[0][i-1],dp[2][i-1]-nums[i]); //没股票 冷冻期 dp[1][i]=dp[0][i-1]+nums[i]; //没股票 非冷冻期 dp[2][i]=Math.max(dp[2][i-1],dp[1][i-1]); } return Math.max(dp[1][nums.length-1],dp[2][nums.length-1]); }}6️⃣.买卖股票(有手续费)//给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。返回获得利润的最大值。注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。class Solution { public int maxProfit(int[] prices, int fee) { int buy = -prices[0],sale=0; for(int i=1;i&lt;prices.length;++i){ buy = Math.max(buy,sale-prices[i]); sale = Math.max(sale,buy+prices[i]-fee); } return sale; }}2.总结提炼🎯 " }, { "title": "📐算法_排序算法", "url": "/posts/%E7%AE%97%E6%B3%95_%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/", "categories": "", "tags": "", "date": "2021-05-01 00:00:00 +0000", "snippet": "一.排序算法🔍1️⃣. 快速排序 ⚡class Solution { //快速排序 public int[] sortArray(int[] nums) { quickSort(nums,0,nums.length-1); return nums; } public void quickSort(int[] nums,int l,int r...", "content": "一.排序算法🔍1️⃣. 快速排序 ⚡class Solution { //快速排序 public int[] sortArray(int[] nums) { quickSort(nums,0,nums.length-1); return nums; } public void quickSort(int[] nums,int l,int r){ if(l&lt;r){ int pos = random_par(nums,l,r); quickSort(nums,l,pos-1); quickSort(nums,pos,r); } } public int random_par(int[] nums,int l,int r){ int t = new Random().nextInt(r-l+1)+l; swap(nums,t,r); return par(nums,l,r); } public int par(int[] nums,int l,int r){ int pv = nums[r]; int i = l-1; for(int j=l;j&lt;r;++j){ if(nums[j]&lt;=pv){ i++; swap(nums,i,j); } } swap(nums,i+1,r); return (i+1); } public void swap(int[] nums,int l,int r){ int t = nums[l]; nums[l]=nums[r]; nums[r]=t; }}2️⃣. 堆排序🚀class Solution { //堆排序 public int[] sortArray(int[] nums) { heapSort(nums); return nums; } public void heapSort(int[] nums){ int len = nums.length-1; buildHeap(nums, len); for (int i = len; i &gt;= 1; --i) { swap(nums, i, 0); len -= 1; rebuildHeap(nums, 0, len); } } public void buildHeap(int[] nums,int len){ for (int i = len / 2; i &gt;= 0; --i) { rebuildHeap(nums, i, len); } } public void rebuildHeap(int[] nums,int i,int len){ for (; (i &lt;&lt; 1) + 1 &lt;= len;) { int lson = (i &lt;&lt; 1) + 1; int rson = (i &lt;&lt; 1) + 2; int large; if (lson &lt;= len &amp;&amp; nums[lson] &gt; nums[i]) { large = lson; } else { large = i; } if (rson &lt;= len &amp;&amp; nums[rson] &gt; nums[large]) { large = rson; } if (large != i) { swap(nums, i, large); i = large; } else { break; } } } public void swap(int[]nums,int l,int r){ int t = nums[l]; nums[l]=nums[r]; nums[r]=t; }}3️⃣. 归并排序💦class Solution { int[] temp; public int[] sortArray(int[] nums) { temp = new int[nums.length]; mergeSort(nums,0,nums.length-1); return nums; } public void mergeSort(int[]nums,int l,int r){ if(l&lt;r){ int mid = l+r&gt;&gt;1; mergeSort(nums,l,mid); mergeSort(nums,mid+1,r); int count=0; int i=l,j=mid+1; while(i&lt;=mid&amp;&amp;j&lt;=r){ if(nums[i]&lt;=nums[j]){ temp[count++]=nums[i++]; }else{ temp[count++]=nums[j++]; } } while(i&lt;=mid){ temp[count++]=nums[i++]; } while(j&lt;=r){ temp[count++]=nums[j++]; } for (int k = 0; k &lt; r - l + 1; ++k) { nums[k + l] = temp[k]; } } }}4️⃣. 💥5️⃣. ❓6️⃣. ❓1️⃣2️⃣3️⃣4️⃣5️⃣6️⃣7️⃣8️⃣9️⃣🔟⚫⚪🟤🟣🔵🟡🔴🟠🟢🧡💛❤💚💙💜🤎🖤🤍💔💕💞💓💗💖💘💝💟💌💢💥💤💦💨💫🈶🈚🆚🉑🉐🈴🈵🈲🚼🅰🅱🆎🆑🅾🆘⛔🛑📛❌⭕❓💯🔅🔆#️⃣*️⃣🔶🔸◾◽⬛🔷🔹💭💬🌙🌈🔥💧⚡⭐🌟🌞🚀🛸🚂🚠🚗🎄🎁💎🥇🥈🥉🏅🏆🎮🔊🔉🎹🎵🎶💰📝📊📌🤝①②③④⑤######" }, { "title": "🚀数据结构 二叉树", "url": "/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/", "categories": "", "tags": "", "date": "2021-04-20 00:00:00 +0000", "snippet": "1.基础算法💡1.1.前序遍历public List&lt;Integer&gt; preorderTraversal(TreeNode root) { List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;()...", "content": "1.基础算法💡1.1.前序遍历public List&lt;Integer&gt; preorderTraversal(TreeNode root) { List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;(); TreeNode p = root; while(p!=null||!stack.isEmpty()){ if(p!=null){ stack.push(p); res.add(p.val); //***** 和中序 遍历就是这里不同 p=p.left; }else{ p = stack.pop(); p=p.right; } } return res; }1.2.中序遍历public List&lt;Integer&gt; inorderTraversal(TreeNode root) { List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;(); TreeNode p = root; while(p!=null||!stack.isEmpty()){ if(p!=null){ stack.push(p); p=p.left; }else{ p = stack.pop(); res.add(p.val); //***** 和前序遍历就是这里不同 p=p.right; } } return res; }1.3.后序遍历public List&lt;Integer&gt; inorderTraversal(TreeNode root) { List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;(); TreeNode curr = root; \t TreeNode pre = null; while(curr!=null||!stack.isEmpty()){ if(curr!=null){ stack.push(curr); curr=curr.left; }else{ \tcurr = stack.peek(); \tif(curr.right==null||curr.right==pre){ res.add(curr.val);// stack.poll(); pre = curr; curr = null; \t}else{ curr = curr.right; \t} } } return res; }1.4.层序遍历class Solution { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { if(root==null) return res; Deque&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();//辅助数据结构-队列 queue.add(root); while(!queue.isEmpty()){ List&lt;Integer&gt; list =new ArrayList&lt;&gt;(); int count = queue.size(); for(int i=1;i&lt;=count;i++){ TreeNode node = queue.poll(); list.add(node.val); if(node.left!=null){ queue.add(node.left); } if(node.right!=null){ queue.add(node.right); } } res.add(list); } return res; }}2.适用题型🎯 3.注意点❗1️⃣注意递归结束的条件❗2️⃣选择合适的辅助数据结构❗-栈/队列4.模板🔑//前中后序模板public int Method() { List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();//栈 TreeNode p = root; while(p!=null||!stack.isEmpty()){ if(p!=null){ stack.push(p); //前序-这里加入结果集 p=p.left; }else{ p = stack.pop(); //中序-这里加入结果集 p=p.right; } } }//层序遍历模板List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { if(root==null) return res; Deque&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();//辅助数据结构-队列 queue.add(root); while(!queue.isEmpty()){ List&lt;Integer&gt; list =new ArrayList&lt;&gt;(); int count = queue.size(); for(int i=1;i&lt;=count;i++){ TreeNode node = queue.poll(); list.add(node.val); if(node.left!=null){ queue.add(node.left); } if(node.right!=null){ queue.add(node.right); } } res.add(list); } return res; }5.对应题目📝\t94. 二叉树的中序遍历\t102. 二叉树的层序遍历\t144. 二叉树的前序遍历\t145. 二叉树的后序遍历103. 二叉树的锯齿形层序遍历\t107. 二叉树的层序遍历 II\t637. 二叉树的层平均值" }, { "title": "📐算法 深度优先遍历", "url": "/posts/%E7%AE%97%E6%B3%95-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/", "categories": "", "tags": "", "date": "2021-04-20 00:00:00 +0000", "snippet": "1.方法总结💡1️⃣通过两次for循环 遍历grid二维数组 根据题意进入递归2️⃣进入递归体后对 边界和遍历过位置return 最后进行上下左右的移动2.适用题型🎯1️⃣岛屿类的题目-求岛屿面积、周长、数量3.注意点❗1️⃣DFS本质是递归-尤其注意递归结束的条件 if(i&lt;0||i&gt;=row||j&lt;0||j&gt;=col||grid[i][j]!=1) return;...", "content": "1.方法总结💡1️⃣通过两次for循环 遍历grid二维数组 根据题意进入递归2️⃣进入递归体后对 边界和遍历过位置return 最后进行上下左右的移动2.适用题型🎯1️⃣岛屿类的题目-求岛屿面积、周长、数量3.注意点❗1️⃣DFS本质是递归-尤其注意递归结束的条件 if(i&lt;0||i&gt;=row||j&lt;0||j&gt;=col||grid[i][j]!=1) return;2️⃣注意审题 看进入递归的条件是什么 不要犯经验主义的错误 1进入还是0 进入 1是陆地还是0是 陆地4.模板🔑class Solution { int res;//根据需要记录答案 int row;//行 int col;//列 public int numEnclaves(int[][] grid) { row= grid.length; col = grid[0].length; //特殊处理 例如:边界0/1的情况要处理 for(int i =0;i&lt;row;i++){ for(int j=0;j&lt;col;j++){ if(grid[i][j]==1){ //是陆地就进入 res++; //按题目要求统计 dfs(i,j,grid);//进行深度遍历 } } } return res; } public void dfs(int i,int j,int[][] grid) { //越界和重复判断 if(i&lt;0||i&gt;=row||j&lt;0||j&gt;=col||grid[i][j]!=1) return;\t\t//遍历过的就设置成别的数 grid[i][j] = 0; //向下遍历 dfs(i-1,j,grid); dfs(i+1,j,grid); dfs(i,j+1,grid); dfs(i,j-1,grid); }}5.经典题目📝​\t岛屿问题🥥​\t\t130. 被围绕的区域​ 200. 岛屿数量​\t\t463. 岛屿的周长​\t 695. 岛屿的最大面积​ 1020. 飞地的数量​ \t1254. 统计封闭岛屿的数目" }, { "title": "📐算法 回溯", "url": "/posts/%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF/", "categories": "", "tags": "", "date": "2021-04-19 00:00:00 +0000", "snippet": "1.方法总结💡回溯方法本质是递归 通过对一个数组或字符串 进行逐个组合 得出结果2.适用题型🎯 类似于\"排列组合\"/\"二维穷举\"的题型3.注意点❗1️⃣.回溯本质是递归-尤其注意递归结束的条件2️⃣.注意审题 看题目是否能组合/选择重复的值 或者是已经选择过的值3️⃣.注意 回溯体内的条件 1.开始条件start 2.执行的次数4️⃣.执行回溯的时候根据题意 选择对参数进行增加或者减少4...", "content": "1.方法总结💡回溯方法本质是递归 通过对一个数组或字符串 进行逐个组合 得出结果2.适用题型🎯 类似于\"排列组合\"/\"二维穷举\"的题型3.注意点❗1️⃣.回溯本质是递归-尤其注意递归结束的条件2️⃣.注意审题 看题目是否能组合/选择重复的值 或者是已经选择过的值3️⃣.注意 回溯体内的条件 1.开始条件start 2.执行的次数4️⃣.执行回溯的时候根据题意 选择对参数进行增加或者减少4.模板🔑class Solution { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); //记录所有的结果 List&lt;Integer&gt; path = new ArrayList();\t //记录每次回溯的结果 public List&lt;List&lt;Integer&gt;&gt; Method(int[] nums, int k) { backTrace(nums,k,0);//开始进入回溯 backTrace 想象成是行row 里面的for循环是 列 col return res;\t\t //返回结果 } public void backTrace(int nums,int k ,int start){ if(k==0){//⚠回溯停止的条件 res.add(new ArrayList(path)); //把每次回溯的结果添加到res集合 return;//return结束方法 } for(int i=start;i&lt;=n-k+1;++i){ //⚠每次进行的回溯 1.i是开始位置 2,回溯长度 3.自增 path.add(i);\t\t\t\t//结果添加到 path集合 backTrace(n,k+1,i+1); //再进回溯(k增加或者减少是根据题目来 i加或者减根据能否取到自身) path.remove(path.size()-1); //把之前添加的 元素 删除 } }}5.相关题目📝\t17. 电话号码的字母组合\t22. 括号生成​\t39. 组合总和​\t40. 组合总和 II​\t46. 全排列​\t47. 全排列 II​\t51. N 皇后​\t52 N皇后 II​\t77. 组合​\t78. 子集​\t79. 单词搜索​\t89. 格雷编码​\t90. 子集 II​\t93. 复原 IP 地址​\t95. 不同的二叉搜索树 II​\t113. 路径总和 II​\t301. 删除无效的括号​\t494. 目标和​\t剑指 Offer 12. 矩阵中的路径​\t剑指 Offer 34. 二叉树中和为某一值的路径​\t剑指 Offer 38. 字符串的排列​\t剑指 Offer II 085. 生成匹配的括号​\t面试题 08.12. 八皇后" }, { "title": "📐算法 滑动窗口", "url": "/posts/%E7%AE%97%E6%B3%95-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/", "categories": "", "tags": "", "date": "2021-04-18 00:00:00 +0000", "snippet": "1.方法总结💡\t窗口从0开始构建，右指针不断地扩大，直到满足 不满足条件停止，改为扩大左指针即缩小窗口，直到再次不满足（满足）条件停止，再改为扩大右指针，直至遍历完数组或字符串2.适用题型🎯 数组或者字符串中求其满足条件的子序列或者子串 将原先需要嵌套循环问题转换为单循环问题 降低时间复杂度3.注意点❗1️⃣右指针何时停止继续扩大2️⃣左指针何时开始缩小4.模板🔑public int Met...", "content": "1.方法总结💡\t窗口从0开始构建，右指针不断地扩大，直到满足 不满足条件停止，改为扩大左指针即缩小窗口，直到再次不满足（满足）条件停止，再改为扩大右指针，直至遍历完数组或字符串2.适用题型🎯 数组或者字符串中求其满足条件的子序列或者子串 将原先需要嵌套循环问题转换为单循环问题 降低时间复杂度3.注意点❗1️⃣右指针何时停止继续扩大2️⃣左指针何时开始缩小4.模板🔑public int Method(int[] nums) { int left = 0, right = 0;//左右指针-维护滑动窗口大小 int res = 0, count = 0;//res记录答案 count计数 判断是否达到规定的窗口大小 \tMap/Set/Array/Queue //辅助数据结构 去重/记录 while (right &lt; nums.length) { //先right指针 遍历数组或字符串 右指针一直扩大 count-增加/减少计数 while (count超过规定的条件) { //也就是窗口什么时候 不能扩大了 -左指针收缩 res去记录答案 count减少/增加计数 left++;//左指针右移 收缩 } int len = right-left+1 //一般会求窗口大小 right++;//右指针右移 } return res; }5.相关题目📝" }, { "title": "Spring", "url": "/posts/Spring/", "categories": "", "tags": "", "date": "2021-03-29 00:00:00 +0000", "snippet": "Spring相关面试题1.⭐简述Spring/*\tSpring框架是一个轻量级的容器框架 包括 IOC和AOP 其核心组件Bean工厂 Bean工厂使用控制反转来降低代码之间的耦合度 并且提供面向切面编程的实现 Spring框架主要由SpringCore SpringAOP SpringMVC SpringDAO 等模块组成\t优点：\t\t1.轻量级：基础版的Spring框架大小约2MB\t\t2....", "content": "Spring相关面试题1.⭐简述Spring/*\tSpring框架是一个轻量级的容器框架 包括 IOC和AOP 其核心组件Bean工厂 Bean工厂使用控制反转来降低代码之间的耦合度 并且提供面向切面编程的实现 Spring框架主要由SpringCore SpringAOP SpringMVC SpringDAO 等模块组成\t优点：\t\t1.轻量级：基础版的Spring框架大小约2MB\t\t2.※控制反转：对java对象的控制权反转到了spring容器\t\t \t\t 原来java对象由程序员直接控制 现在是由spring容器管理\t\t \t\t Spring使用ioc技术实现了业务代逻辑代码和系统服务的解耦 3.※面向切面编程：Spring支持面向切面编程 并且把应用的业务逻辑代码和系统的服务分开 实现解耦 4.※容器技术：用来Spring容器包含并且管理java对象的配置和生命周期 5.MVC框架：Spring中的SpringMVC模块 采用适配器和责任链设计模式实现的一个设计优良的web MVC框架 很好的取代了web框架 6.事务管理：Spring对本地和全局业务提供统一事务管理接口 7.异常处理：Spring提供一个方便的API将特定技术的异常转化成一致的异常*/2.简述Spring Bean的原理/*\t一.Bean的五种作用域：\t\tsingleton：在ioc容器中只允许存在一个java对象的实例(默认情况下是单例) --&gt;单例模式\t\tprototype：在ioc容器中只允许存在多个java对象的实例\t\trequest：每次http request 都创建一个新的Bean\t\tsession：一个http session 定义一个Bean\t\tglobalSession：同一个全局 http session 定义一个Bean\t二.Bean的生命周期： \t1.实例化bean：反射机制 \t2.填充bean属性：poplucateBean方法 \t3.调用Aware接口的相关方法：invokeAwareMethod 完成对beanname beanfactory beanclassloader的赋值 \t4.调用beanPostProcess中的前置处理方法: \t\tapplicationContextPostProcessor \t\t设置applicationContext \t\tenviroment \t5.调用initmethod方法：invokeInitmethod()：判断是否实现initializingBean接口 \t\t\t\t\t\t实现了：调用afterPropertiesSet方法 \t\t\t\t\t\t没实现：不调用 \t6.调用beanPostProcess中的后置处理方法：spring的aop就是在此实现的-&gt;注册destrction的相关回调接口 7.获取完整的bean对象:通过getBean的方式获取 8.销毁:判断是否实现了disposable-&gt;调用destoryMethod方法*/3.⭐简述SpringIOC1.请谈一谈你对IOC的理解：\t核心：控制反转 bean的生命周期 容器\t总：IOC的意思是控制反转　什么控制反转呢　就是对Java对象的控制权从用户手中反转到spring容器上　其中spring容器中使用map集合存储bean　bean作用域默认采用singleton模式　整个bean的生命周期都由spring容器来管理\t分：具体细节记不太清 但我知道IOC的一些底层原理：比如bean是通过反射方式生成的 同时包括很多bean的扩展点 除此之外ioc最核心的也就是填充bean属性和bena的生命周期2.IOC的底层原理：\t核心点：反射　工厂　设计模式\t核心方法： \tcreatBeanFacotry　创建bean工厂 ——&gt;工厂模式 \tgetBean\t\t\t 获取bean对象 \tdoGetBean \tcreatBean \tdoCreatBean 步骤： \t通过creatBeanFacotry方法去创建 bean工厂\t\t开始循环创建对象 因为是单例方式创建的 所以优先通过getBean和DogetBean方式查找 找不到的话\t\t通过creatBean方法或者doCreatBean方法 以反射的方法去创建bean对象\t\t进行对象的属性填充populateBean\t\t进行其他的初始化过程initalingBean⭐3.bean的生命周期： 实例化bean：反射机制实例化bean对象 填充bean属性：popuclateBean方法——&gt;循环依赖——&gt;三级缓存 -调用Aware接口的相关方法：(invokeAwareMethod) 完成对beanname beanfactory beanclassloader的赋值 -调用BeanPostProcess中的前置处理方法:设置applicationContext 调用initmethod方法： 判断是否实现initializingBean接口 \t\t - 实现了：调用afterPropertiesSet方法 \t\t 没实现：不调用 调用beanPostProcess中的后置处理方法：spring的aop就是在此实现的 以及 -注册destrction的相关回调接口 获取完整的bean对象:通过getBean的方式获取 销毁:判断是否实现了disposable-&gt;调用destoryMethod方法4.Spring怎么解决循环依赖问题：5.BeanFactory和Factorybean的区别\t相同点：都是用来创建bean的\t不同点：\t\tBeanFactory严格遵循bean的生命周期 太复杂\t\tFactoryBean能简单的定义对象 并且交给ioc去管理4.⭐简述SpringAOPAOP: 意思是面向切面编程 是处理横切性问题的 横切性问题一般是不会影响到主程序的逻辑实现\t 但是会遍布代码块各处 aop就是把业务逻辑代码和系统服务分开 来达到解耦的目的总：AOP是IOC的拓展功能 在bean的生命周期的BeanPostProcrss的后置处理方法时候实现的\t底层原理是采用的代理模式(不直接调用实际对象 通过代理的方式 间接调用对象)去实现 主要应用在日志和事务中分：在bean的创建过程中 会调用BeanPostProcessor的后置处理方法 来实现AOP 具体实现步骤：\t1.代理对象的创建\t2.通过jdk或者cglib来生产代理对象(JDK:被代理的对象是接口 CGLIB:被代理的对象是类)\t3.在执行方法调用的时候 会生成的字节码文件直接找到dynamicAdvicedIntercepter类中的intercrept方法开始执行\t4.根据之前定义好的通知来生成拦截器 ——&gt; 生成一条拦截链(责任链模式)\t5.从拦截器中依次获取每一个通知开始进行执行代理模式：\t概念：不直接调用实际对象 通过代理的方式 间接调用对象的属性和方法分类：\t1.静态代理\t2.动态代理⭐\t\t应用：Spring的AOP使用动态代理模式实现：\t一个接口\treal类 实现接口\tproxy类 实现接口\t通过proxy类获取到real的属性方法5.⭐简述SpringMVC的执行流程1.什么是MVC?\t是一种软件架构方案：为了解决代码耦合性、提高代码复用 把复杂的web应用分成逻辑清楚的及部分 简化开发\tM:Model：模型 指 各个功能的实现 V:View:视图层：指展示给用户看的页面 与用户的交互的页面 C:Controller:控制器负责将视图与模型一一对应起来 相当于一个模型分发器2.SpringMVC的具体执行流程： 1.用户发送请求到前端控制器 DispatcherServlet 2.DispatcherServlet 收到请求 使用HandlerMapping处理器映射器 请求获取Handle 3.处理器映射器 根据请求url找到具体处理器 生成处理器对象以及处理器拦截器 一并返回给DispatcherServlet 4.DispatcherServlet调用HandlerAdapter处理器适配器 5.根据HandlerAdapter 经过适配调用 具体处理器 6.Handler执行完成后返回 ModelAndView 7.HandlerAdapter将执Hander执行结果ModelAndView返回给DispatcherServlet 8.DispatcherServlet 将 ModelAndView传给ViewResolver视图解析器进行解析 9.ViewResolver解析后返回具体View 10.DispatcherServlet对View解析渲染 11.DispatcherServlet 响应用户 简单来说： 客户端发送请求-&gt; 前端控制器 DispatcherServlet 接受客户端请求 -&gt; 找到处理器映射 HandlerMapping 解析请求对应的 Handler-&gt; HandlerAdapter 会根据 Handler 来调用真正的处理器开处理请求 并处理相应的业务逻辑 -&gt; 处理器返回一个模型视图 ModelAndView -&gt; 前端解析器再把视图模型 ModelAndView 发送给视图解析器进行解析 -&gt; 返回一个视图对象-&gt; 前端控制器 DispatcherServlet 进行视图的解析和渲染-&gt; 将得到视图对象返回给用户6.简述Spring事务7.简述Spring框架中用到的设计模式单例模式：bean都是单例的原型模式：指定作用域为 prototype工厂模式：beanfactory⭐模板方法：postProcessBean⭐策略模式：xmlBeanDefinition⭐观察者模式：listener ,event,适配器模式：adapter⭐装饰者模式：BeanWrapper责任链模式：使用aop的时候生成一个拦截链代理模式：aop的原理：动态代理⭐委托者模式：delegate" }, { "title": "Os", "url": "/posts/OS/", "categories": "", "tags": "", "date": "2021-03-29 00:00:00 +0000", "snippet": "操作系统常见面试题1.⭐线程和进程的区别\t\t\t\t进程\t\t\t\t\t\t\t\t\t\t\t线程概念\t\t系统资源分配的基本单位\t\t\t\t\t\t\tCPU任务调度和分配的基本单位\t\t\t\t\t资源\t\t拥有资源\t\t\t\t\t\t \t\t\t 不拥有资源(线程可以访问隶属进程的资源)开销\t\t开销大(分配资源和设备、保存旧cpu现场和新cpu环境) 只需要保存少量的寄存器内容\t\t 开销小※通信\t\t进程间通信需要借助IPC&lt;引...", "content": "操作系统常见面试题1.⭐线程和进程的区别\t\t\t\t进程\t\t\t\t\t\t\t\t\t\t\t线程概念\t\t系统资源分配的基本单位\t\t\t\t\t\t\tCPU任务调度和分配的基本单位\t\t\t\t\t资源\t\t拥有资源\t\t\t\t\t\t \t\t\t 不拥有资源(线程可以访问隶属进程的资源)开销\t\t开销大(分配资源和设备、保存旧cpu现场和新cpu环境) 只需要保存少量的寄存器内容\t\t 开销小※通信\t\t进程间通信需要借助IPC&lt;引申进程间的通信&gt;\t\t 线程间通信 通过直接读写同一个进程下的数据协程：轻量级的线程 异步 一个线程和进程都可以有多个协程 用户自己控制 拥有自己的寄存器和上下文2.⭐进程间的通信方式7种：1.父子进程通信管道pipe：半双工 只允许有亲缘关系的进程使用2.命名管道FIFO:半双工 允许没有亲缘关系的进程使用3.消息队列：4.共享内存：能被其它进程访问的一段内存 是ipc中最快的5.信号量：通常最为锁机制 控制多个进程对共享资源的访问6.socket：可以不同主机之间使用7.信号：用于通知和接收进程某个事件已经发生IPC:包括消息队列、信号量和共享内存3.⭐进程调度算法进程调度任务过程：\t首先保存当前进程的cpu现场\t然后调度算法选取进程\t把cpu分给调度到的进程\t1.先来先服务和短作业优先调度算法2.高优先权优先调度算法3.高响应比优先调度算法4.基于时间片的轮转调度算法4.⭐死锁和处理方法⭐概念：进程双方都在等待对方的资源释放 自己才能继续执行的情况原因：\t1.竞争不可抢占资源：不可抢占资源 资源给系统分配到进程后 不能自动释放 需要使用完之后 才能释放\t2.竞争可消耗资源：可消耗资源 由进程动态创建和消耗的\t3.进程运行过程中 对资源的分配和释放不当⭐条件：\t1.互斥条件：资源只能倍一个线程独有 别的进程使用需要等待其释放\t2.请求保持：自己有一个资源 但是还要别人碗里的 但别人的被占领的 此时请求进程被阻塞 但又不释放自己手里的\t3.循环等待：发生死锁时候 必然形成一个资源循环链\t4.※不可抢占：进程在使用完成之前不可以被其他线程抢占⭐处理方法\t1.预防死锁:\t\t1.破坏请求保持条件：\t\t\t允许一个进程只获得允许初期所需资源后 开始运行 \t\t\t进程过程中在逐步释放已分配给自己的 且已经用完的资源 在请求新的资源\t\t2.破坏 循环等待条件： \t 对所有资源类型进行线性的排序 避免死锁：银行家算法 检查死锁：资源分配图和※死锁定理 解除死锁： \t1.抢占资源：从一个或多个进程中抢占足够多的进程取分配给死锁 ※2.终止进程：终止系统中的一个或者多个 死锁进程 直到打破循环5.⭐虚拟内存虚拟存储器：\t程序在运行之前不要全部装入内存 只要把那些少数页面装入内存 其余部分留在盘上 \t如果它要访问的页段已经调入内存 那就继续执行下去 \t如果没有调入内存 就称为缺页 那就发出缺页中断 此时os将利用请求调页功能将他们调入内存 使进程执行下去\t如果内存满了还需要利用页的置换功能 将内存中暂时不用的页段调用到盘上 腾出空间 将访问的页段调入内存 页面置换算法：\t1.最佳置换算法：淘汰未来一段时间不会使用的页面\t2.先进先出置换算法：\t⭐3.最近最久未使用的置换算法LRU：使用次数\t4.clock置换算法：所有页面构成循环队列检查当前位置访问位\t\t是0：选择该页面换出\t\t\t\t是1：指针往下走 寻找下一个页面\t5.最近最少未使用的置换算法LFU：访问频率\t快表：\t出现原因：页表存在内存中 每次读取数据都到访问两次内存 第一次是访问内存中的页表 得到物理块号 再将物理块和偏移量拼接 形成物理地址 第二次访问内存的时候才能得到所需数据 为了提高地址变换速度 出现了快表 \t快表 存放当前访问过的页表项 一次访问快表即可得到物理块号 直接形成物理地址\t\t虚存的作用：\t内存完整性 安全 数据共享 swap\t分页和分段的区别\t\t\t\t 分页 \t\t\t 分段\t\t\t\t系统行为\t\t\t用户行为\t\t\t\t信息的物理单位\t\t 信息的逻辑单位\t\t\t\t大小固定\t\t\t大小动态改变\t\t\t\t一维地址空间\t\t 二维地址空间⭐简述物理地址和逻辑地址\t\t\t\t\t物理地址:程序在内存上的真正地址 逻辑地址:程序编译之后 产生的一个逻辑地址6.⭐IO管理1.网络请求处理过程\t客户端 发送网络请求 到网卡\t网卡 再复制数据到 内核缓冲区 \t内核缓冲区 再复制 到web服务器进程 \t服务器 再处理请求构建响应\t服务器 再把数据复制到 内核缓冲区 \t内核缓冲区 把数据复制给 网卡 \t网卡 把数据返回 \t2.IO模型\t1.阻塞式IO:应用程序被阻塞 直到数据从内核缓冲区复制到应用进程缓冲区才结束\t2.非阻塞式IO:应用进程可以继续执行 但是需要不断的使用系统调用来获知IO是否完成\t3.※IO复用:单个进程拥有处理多个IO的能力\t4.信号驱动IO:内核在数据到达时向进程发送信号\t5.异步IO:内核完成所有操作之后向应用进程发送信号\t\t※IO多路复用：\t\t多个IO操作都能在同一个进程并发按顺序完成 复用指的是复用同一个进程\t\t\t\tselect：轮询方式处理 基于数组实现 大小为1024 监听1024个描述符 三种事件对应读写异常\t\tpoll： 轮询方式处理 基于链表实现 大小没限制 监听多个事件 \t\tepoll：采用回调方式检测就绪实现 不需要遍历 时间复杂度为O(1)" }, { "title": "Net", "url": "/posts/Net/", "categories": "", "tags": "", "date": "2021-03-29 00:00:00 +0000", "snippet": "计算机网络1.⭐OSI七层模型和TCP-IP五层模型应用层：\t作用：为特定的应用程序提供一个传输服务\t协议：HTTP、HTTPS、FTP、DNS\t传输层：\t作用：为两台主机之间的应用程序提供一个通用的端到端数据传输服务\t协议：TCP、UDP\t协议数据单元：数据段\t\t\t\t网络层：\t※作用：为分组交换中的不同主机提供通信服务\t(1)通过一定的算法 让互联网中的所有路由器生成的一个用来转发分组的转...", "content": "计算机网络1.⭐OSI七层模型和TCP-IP五层模型应用层：\t作用：为特定的应用程序提供一个传输服务\t协议：HTTP、HTTPS、FTP、DNS\t传输层：\t作用：为两台主机之间的应用程序提供一个通用的端到端数据传输服务\t协议：TCP、UDP\t协议数据单元：数据段\t\t\t\t网络层：\t※作用：为分组交换中的不同主机提供通信服务\t(1)通过一定的算法 让互联网中的所有路由器生成的一个用来转发分组的转发表&lt;分组&gt;\t(2)当前路由器根据分组中的转发表 把分组转发到下一个路由器 让源主机运输层传下来的分组到达目的主机&lt;转发&gt;\t协议：IP、ARP\t设备：路由器\t协议数据单元：数据包数据链路层：\t作用：\t\t它控制网络层与物理层之间的通信 其主要功能是在不可靠的物理介质上提供可靠的传输。\t\t把网络层传下来的数据进行进行封装成帧发送到链路上 以及 把接收到的帧中的数据交给网络层 \t\t协议：\t设备：交换机、网桥\t协议数据单元：帧物理层：\t作用：屏蔽传输媒体和通信手段的差异 让连接的计算机在传输媒体上传输数据比特流 \t协议：\t设备：集线器\t协议数据单元：比特2.⭐TCP-UDP的区别\t \t\t\t\t TCP\t\t\t\t\t UDP是否连接\t\t\t 有连接\t\t\t\t\t无连接\t数据载体\t\t\t 面向字节流\t\t\t\t 面向报文速度效率安全性\t\t\t\t \t\t\t\t几对几应用\t\t\t\t \t丢包\t\t\t\t\t不丢包\t\t\t \t\t 丢包其他\t\t\t\t 有拥塞控制\t\t\t\t无拥塞控制3.⭐TCP头部报文段的结构IP数据报的数据 = 头部报文段+数据TCP头部作用：存放一些决定tcp功能的字段TCP头部结构：\t源端口号和目的端口号 \t\t头部长度：头部的最大长度 60个字节 \t\t序号(seq)： 当前报文段的第一个数据字节的序号\t\t※确认号(ack)：期望接收到对方下一个的报文段的第一个数据字节的序号\t\t标志位：\t\t1.ACK：传送的报文是否有效 \tACK=1 表示有效\t\t2.SYN：用于连接时候的同步位 一般和ACK一起使用表示 是否能建立连接\t\t3.FIN：用于连接释放的时候使用 \t\t※4.RST：表示当前报文段是否要重新建立连接\t\t※5.PSH：提示接收端要尽快取走当前缓冲区的数据 不需要等到缓冲区的数据满了再取 (赶快拿走)\t\t6.URG：紧急指针是否有效 URG=1 紧急指针有效 表示当前报文段的数据是紧急的 要快点传送\t\t\t紧急指针：表示紧急传送数据的大小 在 URG=1才有效\t ※窗口大小:TCP流量控制的手段 告诉发送方 当前报文段的缓冲区还能接受多少数据 告诉发送方自己收多少数据 校验和：当前报文段在传输过程中有没有出现错误 选项：可变长度的字段 表示当前tcp的一些拓展字段 如：最大报文段长度、窗口扩大、时间戳、选择确认 填充：使当前TCP首部长度是4的整数倍4.IP头部结构源ip地址和目的ip地址头部长度可选字段：一些拓展功能填充：让头部字段长度成为4的整数倍首部检验和：判断当前ip数据包在运输过程中是否损坏版本：当前ip协议使用的版本区分服务：为了获取更好的服务总长度：首部和数据部分的总长度标识：唯一标识一个ip数据报标志：为了分片而存在的字段 \t 如果为DF DF=1 表示不可以分片 如果为0可以分片\t 如果为MF MF=1 表示后面还有分片 如果为0则当前是最后一个片偏移：分片相对于原始数据报开始处的偏移生存时间：最大的跳数5.⭐TCP三次握手和四次挥手的过程以及原因三次握手： 建立全双工的一对一可靠连接四次挥手： 释放连接6.⭐简述TIME_WAIT和CLOSE_WAIT的区别7.⭐TCP协议-如何保证可靠传输1.序号和ACK2.头部校验和3.超时重传4.流量控制5.拥塞控制\t慢开始\t\t拥塞窗口慢慢变大 \t拥塞避免\t\t拥塞窗口加法增大\t快重传\t\t连续收到三个重复确认就立即重新发送对方未收到的数据 不必等待设置的重传计时器到期\t快恢复\t\t从拥塞避免开始8.DNS域名解析9.⭐HTTP报文结构HTTP请求报文结构请求行：\t方法：对请求对象的操作\t\t※GET：查看请求的url资源\t\t※POST：添加请求的url资源\t\tPUT：修改请求的url资源\t\tDELETE：删除请求的url资源\t⭐URL：统一资源定位符：从互联网上得到资源和访问这些资源的方法\t版本：http的版本\t\thttp1.1支持 长连接 流水线 ⭐请求头部\t首部字段和值 请求数据HTTP响应报文结构状态行：\t版本：http的版本号\t状态码：响应的状态\t\t1xx:表示通知信息\t\t2xx:表示请求成功信息\t\t\t200：请求成功\t\t3xx:表示完成某些请求之前还要做的事\t\t\t301：永久重定向\t\t\t302：临时重定向\t\t4xx:表示客户端错误信息\t\t\t400：客户端内部语法错误\t\t ※401：客户端未经授权\t\t\t403：服务器拒绝访问\t\t\t404：目标资源找不到 url错误\t\t5xx:表示服务器错误信息\t\t\t500：服务器内部发生不可预期的错误\t\t\t503：服务器收到请求但是不能处理 过一段时间可能恢复正常\t短语：响应头部\t首部字段和值 响应数据⭐10.Get和Post的区别作用安全参数幂等缓存底层⭐11.Cookie和Session以及它们的区别存储位置支持存储的数据类型数据大小安全性12.短链接、长连接和流水线短连接： 长连接：流水线：⭐13.Http和Https以及它们之间的区别SSL使https 有了 加密 认证和完整性的功能 证书授权14.Http和Ftp的区别同：\t都是应用层的协议\t都是建立在tcp协议的基础上\t异：\thttp是超文本传输协议 面向网页 \t\t ftp是文件传输协议 面向文件\thttp控制信息 带内传送 \t\t ftp是带外传送\thttp是无状态的\t\t\t\t\t ftp则需要在整个会话期间 保存用户的状态信息\thttp使用持久连接和非持久连接都可以 ftp是传输文件的时候 使用控制连接(持久连接)和数据连接(非持久连接)⭐15.输入一个网址背后的原理1.输入URL2.DNS解析3.建立TCP连接(三次握手)4.浏览器发送http请求报文5.服务器做响应 然后发回http响应报文6.浏览器获取到响应信息 然后解码 进行页面的渲染 7.浏览器发送异步请求 请求数据8.TCP连接的释放(四次挥手)" }, { "title": "Jvm", "url": "/posts/JVM/", "categories": "", "tags": "", "date": "2021-03-29 00:00:00 +0000", "snippet": "JVM⭐JVM总述Java文件(.java):通过javac命令生成字节码文件一.class文件:字节码文件\t魔数:标识该文件是否是class文件(是一个固定的值:0XCAFEBABE) \t主次版本号:\t常量池:\t\t 字面量:\t\t 符号引用:(对应L类加载的解析步骤:把常量池中的符号引用改为直接引用)\t\t \t 类和接口的全限定名\t\t \t 字段的名称和描述符\t\t \t 方法的名称和描述符\t\t \t...", "content": "JVM⭐JVM总述Java文件(.java):通过javac命令生成字节码文件一.class文件:字节码文件\t魔数:标识该文件是否是class文件(是一个固定的值:0XCAFEBABE) \t主次版本号:\t常量池:\t\t 字面量:\t\t 符号引用:(对应L类加载的解析步骤:把常量池中的符号引用改为直接引用)\t\t \t 类和接口的全限定名\t\t \t 字段的名称和描述符\t\t \t 方法的名称和描述符\t\t \t\t class文件中的项constant_pool_count的值为1, 说明每个类都只有一个常量池\t\t 常量池中的数据也是一项一项的没有间隙的依次排放。\t\t 常量池中各个数据项通过索引来访问有点类似与数组只不过常量池中的第一项的索引为1, 而不为0.\t \t类或接口的访问修饰符:\t类索引:\t父类索引:\t接口索引的集合:\t字段表集合:描述一个字段的信息\t\t作用域: public protected private\t\t是否为静态变量: static\t\t可变性: final\t\t序列化: transient\t\t并发可见性: volatile\t\t数据类型: int double\t\t字段名: student1..\t方法表集合:描述一个方法的信息\t属性表:描述一个额外的信息\t二.类加载器:用来加载class类文件到运行时数据区\t类加载器分类:\t\t启动类加载器:加载 jre\\lib文件下的类\t\t拓展类加载器:加载 jre\\lib\\ext文件下的类\t\t应用程序类加载器:加载 class path 文件下的类\t\t自定义类加载器:继承CLassLoader类 \t重写findclass方法:保持双亲委派模型 \t重写loadclass方法:不保持双亲委派模型 双亲委派模型: 双亲委派的概述: \t在加载类到运行时数据区的时候 类加载器收到类加载请求 优先把这个请求 给父类加载器区处理 \t父类加载器收到请求 如果自己没有父类 则处理请求 如果有则还是交给父类的父类去处理 \t如果处理成功 则后续有同样的类要加载 会使用父类加载的类 而不是子类 如果处理失败则交给向下交给处理类加载请求 双亲委派的打破: \t ①自定义类加载器:继承CLassLoader类 重写loadclass方法:不保持双亲委派模型 ②自身缺陷:双亲委派模型解决了越是基础的类 就越优先加载 但是如果基础类要调回自己的用户代码 则要打破\t\t\t\t 双亲委派模型 使用线程上下文类加载器\t 类加载的过程: \t·加载: \t\t 通过class文件中 常量池的符号引用中的 类和接口的全限定名 \t\t 把class字节码文件转化成该类的二进制流数据 解析这个二进制流把它的静态数据结构转化方法区中的动态的数据结构 创建一个该类型的运行时类的实例 (java.lang.classL类实例) 此过程有父类先加载父类 懒加载 \t·链接: \t\t验证: 验证加载后的二进制数据流信息是否对JVM有害 \t\t准备: 在方法区为静态变量分配空间 以及 赋默认值 \t\t解析: 把常量池中的符号引用改为直接引用--&gt;静态链接(类加载时)[对比虚拟机栈的动态链接(方法运行时)] \t\t \t·初始化:执行clint()方法 执行赋值操作 有父类先执行父类的赋值 而且是懒加载 需要的时候才加载 \t\t 把非final静态变量赋初始值 执行静态代码块 \t\t \t static final 类型变量存放在哪? \t \t首先它不进行初始化 它是一个常量 \t\t\t调用这个static final 变量的时候 会把它加载自身类(main方法中)或者方法区的常量池的字面量中 \t\t\t(大于short.MAX_VALUE) 三.运行时数据区:\t·栈:处理方法的执行和调用\t\t虚拟机栈:\t\t\t处理普通方法的执行服务\t\t\t每一次调用普通方法时 就会创建一个栈帧它包含\t\t\t\t局部变量表:保存局部的遍历 包括基本数据类型 对象的引用\t\t\t\t操作数栈:\t\t\t\t动态连接:将方法区中运行时常量池的符号引用改为直接引用\t\t\t\t方法的出入口信息:\t\t\t一个方法的开始和结束就对应一个栈帧的入栈和出栈\t\t本地方法栈:\t\t\t为本地方法提供服务\t·堆:\t\t存放实例对象和数组对象的区域 GC主要回收的区域\t\t\t\t分区:\t\t\t新生代:\t\t\t\tEden:首次对象被分配到这\t\t\t\tFromSurvivor:\t\t\t\tToSurvivor:\t\t\t老年代:用于存放大对象\t\tGC:\t\t 垃圾回收器 通过一定的 垃圾回收算法 回收 垃圾 \t垃圾: \t\t通过可达性分析法 判断对象是否是垃圾 \t\t通过GCRoot的对象作为起点从这些起点开始向下遍历 \t\t如果GcRoot后面没有相连接的引用则说明该对象是垃圾 \t\t我们把遍历对象过程中遇到的对象，按\"是否访问过\"这个条件标记成以下三种颜色： \t\t 白色：尚未访问过\t\t\t\t黑色：本对象已访问过，而且本对象引用到的其他对象也全部访问过\t\t\t\t灰色：本对象已访问过，但是本对象引用到的其他对象尚未全部访问完\t\t\t\t具体过程:\t\t\t\t1.初始时，所有对象都在【白色集合】中；\t\t\t\t2.将 GC Roots 直接引用到的对象放到【灰色集合】中；\t\t\t\t3.从灰色集合中获取对象：\t\t\t\t\t3.1. 将本对象引用到的其他对象全部挪到 【灰色集合】中；\t\t\t\t\t3.2. 将本对象挪到【黑色集合】里面。\t\t\t\t4.重复步骤3，直至【灰色集合】为空时结束。\t\t\t\t5.结束后，仍在【白色集合】的对象即为 GC Roots 不可达，可以进行GC\t\t\t\t\t\t\t\t \t\t可作为GC Root对象的引用: \t\t\t1.虚拟机栈的引用对象 \t\t\t2.方法区中类静态变量引用对象 \t\t\t3.方法区中常量池引用对象 \t\t\t4.本地方法引用对象 \t\t \t \t垃圾回收算法: \t\t1.复制算法： 在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着\t\t 进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的\t\t 年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会\t\t 被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经\t\t 被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的\t\t “From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重\t\t 复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。 \t\t2.标记清除算法： \t\t\t标记出所有要回收的对象 等到标记完后再统一清理 \t\t\t缺点：容易产生碎片 后续有连续的对象不方便使用 \t\t3.标记整理算法： \t\t\t标记出所有要回收的对象 让所有存活的对象向一端移动 清理掉边界外的内存 \t\t4.分代收集算法： \t\t\t新生代：复制算法 \t\t\t老年代：标记整理或者标记清除算法 \t \t垃圾回收器: \t1.新生代垃圾回收器： \t\t①serial: \t\t\t单线程垃圾收集器 在垃圾收集时 用户线程必须停止 \t\t②parNew: \t\t\t多线程版本的serial 能并行的多线程垃圾回收器 \t\t③parallel: \t\t\t并行的多线程的垃圾回收器 和parNew类似 侧重点是高吞吐量 \t2.老年代垃圾回收器： \t\t①serial old: \t\t\tserial的老年代版本 采用标记整理算法 \t\t②parallel old: \t\t\tparallel的老年代版本 并行多线程的垃圾回收器 侧重点是吞吐量 采用标记整理算法 \t\t③CMS: \t\t\t并发标记清除垃圾收集器 采用标记清除算法 适合高响应比的场景 \t\t\t步骤： \t 初始标记：暂停所有用户线程 让gc线程启动 记录下与gcroot相连的对象 \t 并发标记：开启用户和gc线程 gc线程继续在gcroot进行标记 但用户线程继续更新对象的引用域 \t 重新标记：为了修正并发标记期间用户线程继续运行而产生变动的那一部分对象的标记记录 \t 并发清除：用户和gc线程同时开启 gc线程开始在标记区域垃圾回收 \t \t \t3.新生代老年代都可使用: \t\tG1:是唯一可以在老年代和新生代使用的垃圾收集器 使用标记整理算法 性能兼顾相应比和吞吐量 \t它的核心是把内存分为大小一样的region 每一个region都可以作为 eden s0 s1 和 old gen 该垃\t\t\t\t圾收集器 会优先回收价值最高的区域 避免了垃圾碎片 最大的好处是化整为零，避免全内存扫描，只\t\t\t\t\t需要按照区域来进行扫描即可 避免了全内存区的GC操作 \t·方法区:\t\t存放已经被类加载的信息、常量、静态变量、运行时常量池、及时编译器编译后的代码\t\t\t运行时常量池:\t\t\t\t字面量:\t\t\t\t\t字符串的值\t\t\t\t\t八大基本类型的值\t\t\t\t\t被声明为final的常量(长度大于Short.MAX_VALUE):static final int k=1;\t\t\t\t符号引用:\t\t\t\t\t类和方法的全限定名\t\t\t\t\t字段的名称和描述符\t\t\t\t\t方法的名称和描述符\t\t具体实现:\t\t\tJDK1.8前:永久代\t\t\tJDK1.8后:元空间\t\t\t\t\t\t永久代：和堆相连接 存放类运行的必要资源 大小固定容易出现内存泄露问题\t\t\t元空间：改用本地内存实现方法区 解决了永久代内存泄露的问题 大小一般有本地内存决定\t\t\t\t\t\t使用原空间代替永久代的原因：\t\t\t\t①字符串类型容易出现内存泄漏问题\t\t\t\t②运行时动态产生的类数量不确定 所以永久代的大小问题难确定 大了浪费空间 小了泄露\t\t\t\t③为了融合jrocket VM 和hotspot实现的虚拟机 ORICAL公司决定取消 因为jrocket没有永久代\t\t四.程序计数器:用来记录class字节码文件到了哪一行五.执行引擎:六.本地接口:七.本地方法库:1.⭐JVM运行时数据区组成1.栈 ⭐虚拟机栈：(处理方法的调用) \t\tJava方法执行的内存模型 每个方法被调用时 都会同步创建一个栈帧 用于存储局部变量表(局部变量) \t\t[基本数据类型和对象引用(类的变量名)] 操作数栈 动态连接 方法出入口等 每一个方法被调用直到执行完毕 \t\t对应一个栈帧在虚拟机栈中从入栈到出栈的过程 本地方栈：为JVM使用本地方法服务 2.⭐堆(线程共享)：存放对象实例和数组(new ),对象实例在此分配内存 GC回收的主要区域 新生代： \tEDEN:\t\tFrom-Surivor： To-Surivor： 老年代： 3.⭐方法区(线程共享) 存储 已被JVM加载的类信息(类)、常量、静态变量、即时编译器编译后的代码和⭐运行时常量池 \t运行类常量池：存放编译期 生成的各种 字面量 和 符号引用 \t\t\t\t字面量：文本字符串(String)、8大基本数据类型、final常量 \t\t\t\t符号引用：类和方法的全限定名、字段的名称和描述符、方法名称和描述符4.程序计数器：记录当前线程所执行到字节码的行数 2.简述永久代和元空间1.永久代：\tJVM规范中方法区在hotspot的一种实现\t容易出现永久代内存泄露 java8用元空间代替永久代2.元空间：\t是对JVM规范中方法区的具体实现\t不再和堆连接 存于本地内存中 默认情况原空间可以使用本地内存 为了不让它无限扩张 jvm提供参数限制大小\t元空间的本质和永久代类似 不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，元空间的大小仅受本地内存限制3.为什么JDK8要用元空间代替永久代? Ⅰ.字符串(string类 存在 方法区) 在永久代中 容易出现性能和内存泄漏问题 Ⅱ.类和方法的信息难确定大小(永久代是指定大小的 大了老年代溢出 小了永久代溢出) Ⅲ.永久代为GC带来不必要的麻烦 让回收效率降低 Ⅳ.Oracle可能将Hotspot和JRockit合二为一 JRockit 没有永久代3.⭐如何判断对象已经死/什么是垃圾/垃圾回收器的回收的是什么东西?1.引用计数法：\t有地方引用它 计数器+1 引用失效 -1 为0的对象不能被使用 \t使用这个算法是因为它很难解决对象相互循环引用的问题2.⭐可达性分析法：\t①通过一个叫GC Root的对象作为起点 从这些起点开始向下搜索 节点所走过的路径称为引用链 当一个对象没有引用链时 说明该对象不可用 \t②可作为GC Root对象：\t\t虚拟机栈的引用对象\t\t方法区中的静态属性引用的对象\t\t方法区中常量引用对象\t\t本地方法的引用对象\t③上述不可用的对象 并非是非死不可 真正一个对象的死亡 至少要经过两次标记过程\t 不可达对象被第一次标记并且进行一次筛选筛选条件：是否有必要进行finalize方法) 没有必要执行(对象没有覆盖finalize方法或finalize方法被虚拟机调用过时) 有必要执行：被放到一个队列中进行第二次标记除非这个对象和引用链上的任何一个对象建立关联 否则会被真的回收 ⭐补充:三色标记法4.⭐简述强软弱虚引用强引用：当堆内存不足时候 强引用对象 不会被回收 而是抛出异常软引用：当内存足够 不会被GC回收 不足时 才被回收弱引用：被弱引用关联的对象只能生存到下一次 GC回收前、虚引用：被虚引用关联的对象随时可能被回收虚引用和软、弱引用的区别：\t①虚引用必须和引用队列一起使用：可以通过判断引用队列是否加入了虚引用 来判断 是否要被垃圾回收器回收\t②软、弱引用是在引用对象被GC回收后 jvm才把加入引用队列中(GC回收后放入引用队列)\t 而 虚引用 则是在引用对象被GC回收前就加入到与之关联的引用队列\t5.⭐简述垃圾回收算法垃圾回收：在堆内存中 把死亡的对象回收 释放堆内存空间1.标记-清除算法：\t标记出所有要回收的对象 标记完成后统一回收所有被标记的对象(效率低 大量不连续的碎片)2.复制算法：\t在堆内存中把新生代分为 Eden 和 两个survivor\t\t每次使用Eden和一块survior1\t\t回收时 把Eden和Survior1中存活的对象 复制到 另一块Survivor2中 最后 清理之前的Eden和Survivor2\t\t如果存活的大于10% 采用分配担保策略(在第8点中的第2小点) 多出来的直接进入老年代\t\t分配担保政策:\t\tEden 满了——&gt;FromSurvior——&gt;FromSurvior满了——&gt;ToSurvior——&gt;ToSurvior满了——&gt;老年代3.标记-整理算法：\t标记出所有要回收的对象 然后让所有存活的对象向一端移动 然后清理端边界外的内存4.分代收集算法：\t综合上面的算法 根据不同分区采用不同的算法\t新生代：有大量的对象死亡 选择复制算法 只需要复制少量的存活对象就可以完成垃圾回收\t老年代：存放大对象 对象存活记录高 选择 标记清除(CMS收集器) 或者 标记整理算法(G1收集器)6.⭐简述常见的垃圾回收器新生代收集器(复制算法)：\tSerial:单线程收集器 在进行垃圾收集的时候必须暂停其他所有工作线程\tParNew：Serial的多线程版本 支持并行操作 在进行垃圾收集的时候可以执行其他工作线程\tParallel Scavenge:并行的多线程收集器 侧重点的 它的吞吐量 (因为并行 所以吞吐量高)\t老年代垃圾收集器(标记-清除或标记-整理算法)：\tSerial Old: Serial的老年代版本 单线程\tParallel Old: parallel Scavenge 的老年代版本 多线程 并行 侧重于吞吐量 使用标记整理算法\tCMS:\t\t同时启用GC和用户线程 \t\t采用标记清理算法 是一个获取最短回收停顿时间的收集器 高响应比 \t\t但因为采用标记清除算法 容易产生碎片 \t\t无法处理浮动的垃圾(用户线程还在继续执行不断产生垃圾只有到下次GC时候才处理)\t\t低吞吐量(并发标记和并发清除和以用户线程并发执行)新生代和老年代皆可：\tG1收集器：\t\t唯一一个可以在新生代和老年代使用的垃圾收集器\t\t采用标记整理算法 避免碎片\t\t该收集器 将堆内存分为不同大小相等的region 并维护一个优先列表 每次在允许的时间内 回收价值最大的region\t\t高并发性 分代收集7.如何选择垃圾收集器高吞吐量：\t新生代：Parallel Scavenge \t老年代：Parallel Old高响应比：\t新生代：ParNew\t老年代：CMS⭐8.内存的分配和回收/对象何时进行老年代? 当Eden分区 没有足够的空间的时候 虚拟机发起一次Minor GC ·MinorGC 和 MajorGC的区别? Minor GC:在新生代发起垃圾回收 Major GC:在老年代发送垃圾回收 Full GC:在老年代和新生代发生垃圾回收 ·什么时候进行老年代? \t①大对象(需要大量连续内存的对象) 直接进入老年代 \t②空间分配担保： \t\t当Eden满了 然后 把Eden存活的对象复制到FromSurvior 当FromSurvivor 满了 \t\t将存活对象复制到 ToSurvivor 当ToSurvivor 满了 将存活对象送入老年代 \t③年龄判断： \t设置一个年龄计数器 每一次GC存活的对象 计数器加一 到了指定的值后 进入老年代·空间分配担保：\t安全的Minor:老年代中最大的连续可分配空间 大于 新生代 所有对象的空间\t冒险的Minor:老年代中最大的连续可分配空间 大于历代晋生到老年代的平均水平并且允许担保失败 \t\t\t \t\t\t\t\t\t 小于平均值 则直接进行Full GC 让老年代腾出空间 \t9.⭐JVM性能监控和故障处理工具JSP:JSTAT:JINFO:JMAP:JHAT:JSTACK:JVISUALVM:⭐10.Class类文件的组成class类文件的是jvm虚拟机的数据入口组成：\t1.魔数和主次版本号\t2.常量池:\t3.访问标志：类定义标志\t4.类索引:\t5.符类索引：\t6.接口索引的集合:确定一个类的的继承关系\t7.字段表集合: 定义一个字段的限制条件\t\t作用范围：public、private\t\t是否是静态变量：static\t\t是否可变：final\t\t并发可见性：volatile\t\t是否可被序列化：transient\t\t字段的数据类型：int String\t\t字段名称：\t8.方法表集合:\t9.属性表:11.⭐简述JVM中类加载机制什么是类加载机制：\tJVM把描述类的信息从class文件加载到内存并且对数据进行校验 转化解析和初始化类加载的全过程：\t加载：\t\t产生一个二进制数据流 解析这个二进制数据流的静态存储结构转化为方法区的运行时数据结构 创建一个表示该类型的class类的实例 作为方法区这个类的各种数据入口\t验证：\t\t为了确保class文件的数据流信息符合当前虚拟机要求 不会危害虚拟机安全\t准备：\t\t为类变量分配内存并且赋初始值 这些类所使用的内存在方法区进行分配\t解析：\t\t虚拟机将常量池中的符号引用替换为直接引用\t初始化：\t\t真正执行java代码的过程 12.简述JVM中的类加载器和双亲委派模型class类文件是通过类加载器把class文件中的类描述文件加载到内存的类加载器：\t启动类加载器：\t\t将存放到\\lib目录下的类库加载到虚拟机内存\t拓展加载器：\t\t将\\lib\\ext目录下的类库加载到虚拟机内存\t应用程序加载器：\t\t将用户类路径classpath上所指定的类库加载到虚拟机内存\t自定义加载器： \t双亲委派模型：\t当一个类加载器收到类加载请求 先把这个请求委派给父类加载器去完成(所有的请求最终会到顶层的启动类加载器)\t只有当父类加载器完成加载请求 子加载器才回去尝试自己加载⭐双亲委派模型的打破：\t双亲委派模型可以被打破：\t1.历史原因：\t\t双亲委派模型出现在类加载器后 在对用户自定义类加载器 双亲委派模型不得不做一些让步 \t2.反向加载： \t自身的缺陷导致的 如果存在这样一种情况 基础类在把请求交给黑父加载器后 又想调回用户的代码 怎么办？ \t使用上下文类加载器 默认情况下是应用类加载器 3.结构复杂化 \t13.静态分配和动态分配静态分配：\t依赖静态类型的定位方法的分配 发生在编译时期 典型的应用是方法的重载\t动态分配：\t运行时期 根据实际类型来进行方法的分配 发生在程序运行时 应用为方法的重写\t非虚方法：\t所有 静态 final/private方法 通过invokespecial指令调用 对这个非虚方法的符号引用转为直接引用 在编译完成时 \t确定唯一的调用方法虚方法：\t通过invokevirtual指令调用 会有静态或者动态的分配\t根据编译期方法的接收者和方法的参数的静态类型进行分派\t再根据运行时 方法的调用和实际参数来分派14.JVM启动模式Client和Server：\t通过 -client 或者 -server 指定两种模式的区别：\t1.编译器：\t\tclient：轻量级编译器\t\tserver：相对重量级编译器 服务启动后 性能更高\t2.GC： \tclient:新生代(Serial)和老年代(serial old)选择的是串行gc \tserver:新生代和老年代选择 并行gc 3.启动方面： \tclient：启动快 编译快 占内存少 优化客户端启动时间 \tserver：启动慢 编译完全 效率高 优化服务器的最大化程序执行速度 \t15.⭐GC的调优调优目标：\t进入老年代的数量降到最低\t减少Full GC的执行时间\t优化JVM的参数：堆栈大小 设计垃圾收集器的模式优化策略：\t新对象尽可能预留在新生代：\t\t因为FUllGC的代价比MinorGC高 实际项目中更具日志信息分析新生代空间大小是否分配合理　通过-Xmm设置新代\t\t 大小 最大限度的降低新生代进入老年代\t大对象进入老年代：\t\t如果大对象首先分配在新生代 会导致空间不足让年龄不够小的对象分配到了老年代 从而频繁的发生FULL GC\t\t减少FULL-GC的发生次数\t合理的设置进入老年代的对象的年龄： \t降低FullGC 设置稳定的堆大小 以下情况不需要GC优化： \tMinorGC执行时间小于50ms FullGC不到1s16.JVM进程有哪些进程启动main线程处理引用的线程垃圾回收线程发送分发处理请求给JVM的线程接收外部命令的线程" } ]
