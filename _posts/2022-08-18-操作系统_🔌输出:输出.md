> ###### IO硬件原理

###### 1.IO设备

分类
	块设备：信息存储在固定的大小到块中 每个块有自己的地址 块设备的基本特征是每个块都能独立于 其他块而读写 常见的块设备:磁盘、USB
	字符设备：以字符为单位发送或接收一个字符流 不考虑任何块结构 常见的块设备:打印机、鼠标、网络接口

###### 2.设备控制器

​	IO设备由机械部件和电子部件组成
​	而电子部件就叫做 设备控制器 常常以**usb插槽**的形式出现
​	作用：把串行的位流转化成字节块 并进行必要的错误校正工作 字节块在控制器的缓冲区中进行组装 然后对校验和进行校验 如果没有错误就复制到主存

###### 3.cpu和设备控制器的通信

​	`cpu`通过设备控制内部的`寄存器`来对设备进行读写操作
​	此外为了提高数据交换效率 某些设备控制器中还有可读写的缓冲区buffer	

​	cpu怎么和设备的控制寄存器和缓冲区通信?
​	**1.给每个寄存器分配一个IO端口号**
​		通过对控制寄存器的Port内容读写 并将结果写入cpu的寄存器中
​		但这种方式的内存地址空间和io地址空间不同	

​	**2.把每个寄存器映射到内存上**
​		通过对控制寄存器的Port内容读写 并将结果写入cpu的寄存器中

​		IO内存映射的优缺点
​		1.优点：
​				1.1 对于内存映射IO 设备控制寄存器只是内存中的变量 可以直接使用c语言 而 不是用IO内存映射则需要某些 汇编代码 而c语言中不存在执行IN或者OUT指令的方法 这样的调用过程则会增加控制IO的开销
​				1.2 不需要特殊的保护机制来阻止用户进程执行io操作
​				1.3 对于内存映射io 可以引用内存中的每一条指令来引用控制寄存器

​		2.缺点：
​				需要禁用高速缓存 减少了响应速度

###### 直接存储器存取DMA

​			为了提高cpu读设备控制器的效率
​			在cpu和控制器中间加了一层 DMA 他可以调控多个设备的数据传输
​			DMA使用物理内存地址

​			在设备控制器和cpu之间加的一层：不让cpu和设备控制器直接打交道 提高cpu读取设备控制器的数据的效率

###### 中断

​	中断：
​		当硬件完成对应操作 就发出一个中断 通过总线发送到 中断控制器 `中断控制器`通过对应的中断在`中断向量表`的值判断 中断是什么设备的中断 再让`中断处理程序`去做出对应的响应 给 cpu 告诉cpu可以执行其他	操作了 其中涉及了`用户态到内核态到切换 `

==用户态和内核态切换具体做了什么事情？==
	1⃣️通过进程的描述符得到 内核栈的相关信息 ss0和esp0
	2⃣️保存用户栈的信息(程序计数器、程序状态字PSW和寄存器) ss0和esp0指向内核栈  cpu将**用户栈切换到内核栈** (1次cpu使用)
	3⃣️遍历中断向量表的中断信息 载入寄存器 然后通过中断处理程序执行
	4⃣️**再从内核态切换回去**  (1次cpu使用)----合计2次cpu
	

==用户态到内核态消耗了什么 ？==
	1. 频繁的上下文切换 很容易导致 CPU 将大量时间耗费在寄存器、内核栈以及虚拟内存等资源的保存和恢复上，进而大大缩短了真正运行进程的时间。这也正是导致平均负载升高的一个重要因素。
	2.需要管理TLB和cpu的高速缓存 管理其需要cpu的时间片
	3.在有虚拟内存并且必须设置页表或者必须保存MMU状态

> ###### IO软件原理

###### 程序控制IO

用户调用系统调用打印字符
首先把字符缓冲区的复制到内核空间的数组中  查看打印机是否可用 不可用就一直等待 直到可用 
可用的话就把字符复制到打印机的寄存器中 打印完毕后 切换为用户态
这里有个问题就是：输出一个字符后 cpu要不断的查询设备来去了解 它是否就绪接收另一个字符 这种情况称为忙等
程序控制IO很简单但是缺点也很明显 直到全部IO完成前要占用cpu的全部时间 

###### 中断驱动IO

每次打印一个字符后 都要等待其打印完毕 每次就浪费了cpu的执行时间 如果把这个等待时间去做别的事情就能提高效率 等到打印机下一次就绪时候再切换回去 执行打印
这种情况就叫做 中断驱动IO 每次打印一个字符时候调用一个系统调用 用户态切换到内核态 字符串缓冲区被复制到内核的缓冲区 当打印机把字符打印完毕后 会发出一个中断 表示打印任务做完了cpu可用执行其他任务了 并且要保存当前进程的状态

###### 使用DMA的IO

让DMA每次给打印机提供一个字符 不用cpu去提供 将中断的次数从每个字符一个减少到每个缓冲区一次

###### IO软件系统层次

1.中断处理程序
	让之前被阻塞的驱动程序现在能够被继续运行
	要处理中断后的操作 保存用户栈的上下文 程序计数器 psw 等
	 切换到内核栈 

2.设备驱动程序
	作用是去控制IO设备 每个驱动设备控制一类的设备 
	接收上方设备无关性软件发出的抽象读写命令序列 并且把它写到控制器的设备寄存器中

3.设备无关程序
	为设备驱动程序提供统一的接口
	提供缓冲的功能
		无缓冲
		用户空间缓冲
		内核空间的缓冲
		内核空间的双缓冲

4.用户IO程序
	如果用户想调用硬件怎么办？通过系统调用实现
或者是创建守护线程
	守护线程是一个特殊线程
	打印一个文件的时候 先生成要打印的整个文件 然后把它放到假脱机目录下 由守护线程去打印该目录下的文件 只有该线程能使用打印机 通过保护特殊文件来防止用户直接使用 可用解决某些进程不必要的长期空占打印机的问题	

`在IO软件系统中 数据的读取过程`
1.用户需要去文件中读取一个块时
2.操作系统被调用 来实现这一个请求 
3.与设备无关的软件在缓冲区查找要读取的块信息 如果没有则要去使用设备驱动程序区去读取
4.在设备驱动程序中 发出命令去让它从磁盘中获取该块 然后进程被阻塞 直到操作完成
5.当磁盘操作完成后 硬件产生一个中断 用户态切换到内核态 目的是告诉cpu可用做其他事情了 中断处理程启动处理该中断 通过总线 去中断控制器中的中断向量表中去查询哪个设备发生了什么事情 然后中断处理程序从设备提取状态信息然后唤醒 等待的进程 以此结束此次IO 再从内核态切换回用户态 让等待的进程继续运行
