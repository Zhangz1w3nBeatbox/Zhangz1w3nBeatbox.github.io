## 操作系统常见面试题

`1.⭐线程和进程的区别`

```tex
				进程											线程
概念		系统资源分配的基本单位							CPU任务调度和分配的基本单位					
资源		拥有资源						  			 不拥有资源(线程可以访问隶属进程的资源)
开销		开销大(分配资源和设备、保存旧cpu现场和新cpu环境)   只需要保存少量的寄存器内容		 开销小
※通信		进程间通信需要借助IPC<引申进程间的通信>		     线程间通信 通过直接读写同一个进程下的数据

协程：轻量级的线程 异步 一个线程和进程都可以有多个协程 用户自己控制 拥有自己的寄存器和上下文
```

`2.⭐进程间的通信方式`

```
7种：
1.父子进程通信管道pipe：半双工 只允许有亲缘关系的进程使用
2.命名管道FIFO:半双工 允许没有亲缘关系的进程使用
3.消息队列：
4.共享内存：能被其它进程访问的一段内存 是ipc中最快的
5.信号量：通常最为锁机制 控制多个进程对共享资源的访问
6.socket：可以不同主机之间使用
7.信号：用于通知和接收进程某个事件已经发生

IPC:包括消息队列、信号量和共享内存
```



`3.⭐进程调度算法`

```
进程调度任务过程：
	首先保存当前进程的cpu现场
	然后调度算法选取进程
	把cpu分给调度到的进程
	
1.先来先服务和短作业优先调度算法
2.高优先权优先调度算法
3.高响应比优先调度算法
4.基于时间片的轮转调度算法
```



`4.⭐死锁和处理方法`

```
⭐概念：进程双方都在等待对方的资源释放 自己才能继续执行的情况
原因：
	1.竞争不可抢占资源：不可抢占资源 资源给系统分配到进程后 不能自动释放 需要使用完之后 才能释放
	2.竞争可消耗资源：可消耗资源 由进程动态创建和消耗的
	3.进程运行过程中 对资源的分配和释放不当
⭐条件：
	1.互斥条件：资源只能倍一个线程独有 别的进程使用需要等待其释放
	2.请求保持：自己有一个资源 但是还要别人碗里的 但别人的被占领的 此时请求进程被阻塞 但又不释放自己手里的
	3.循环等待：发生死锁时候 必然形成一个资源循环链
	4.※不可抢占：进程在使用完成之前不可以被其他线程抢占
⭐处理方法
	1.预防死锁:
		1.破坏请求保持条件：
			允许一个进程只获得允许初期所需资源后 开始运行 
			进程过程中在逐步释放已分配给自己的 且已经用完的资源 在请求新的资源
		2.破坏 循环等待条件：
           	 对所有资源类型进行线性的排序
     避免死锁：银行家算法
     检查死锁：资源分配图和※死锁定理
     解除死锁：
     	1.抢占资源：从一个或多个进程中抢占足够多的进程取分配给死锁
       ※2.终止进程：终止系统中的一个或者多个 死锁进程 直到打破循环
```



`5.⭐虚拟内存`

```
虚拟存储器：
	程序在运行之前不要全部装入内存 只要把那些少数页面装入内存 其余部分留在盘上 
	如果它要访问的页段已经调入内存 那就继续执行下去 
	如果没有调入内存 就称为缺页  那就发出缺页中断 此时os将利用请求调页功能将他们调入内存 使进程执行下去
	如果内存满了还需要利用页的置换功能 将内存中暂时不用的页段调用到盘上 腾出空间 将访问的页段调入内存 
页面置换算法：
	1.最佳置换算法：淘汰未来一段时间不会使用的页面
	2.先进先出置换算法：
	⭐3.最近最久未使用的置换算法LRU：使用次数
	4.clock置换算法：所有页面构成循环队列检查当前位置访问位
		是0：选择该页面换出		
		是1：指针往下走 寻找下一个页面
	5.最近最少未使用的置换算法LFU：访问频率	
快表：
	出现原因：页表存在内存中 每次读取数据都到访问两次内存 第一次是访问内存中的页表 得到物理块号 再将物理块和偏移量拼接 形成物理地址 第二次访问内存的时候才能得到所需数据 为了提高地址变换速度 出现了快表 
	快表 存放当前访问过的页表项 一次访问快表即可得到物理块号 直接形成物理地址
		
虚存的作用：
	内存完整性 安全 数据共享 swap
	
分页和分段的区别
				  分页 			   分段
				系统行为			用户行为
				信息的物理单位		 信息的逻辑单位
				大小固定			大小动态改变
				一维地址空间		  二维地址空间
⭐简述物理地址和逻辑地址				
	物理地址:程序在内存上的真正地址
    逻辑地址:程序编译之后 产生的一个逻辑地址

```



`6.⭐IO管理`

```
1.网络请求处理过程
	客户端 发送网络请求 到网卡
	网卡 再复制数据到 内核缓冲区 
	内核缓冲区 再复制 到web服务器进程 
	服务器 再处理请求构建响应
	服务器 再把数据复制到 内核缓冲区 
	内核缓冲区 把数据复制给 网卡 
	网卡 把数据返回 
	

2.IO模型
	1.阻塞式IO:应用程序被阻塞 直到数据从内核缓冲区复制到应用进程缓冲区才结束
	2.非阻塞式IO:应用进程可以继续执行 但是需要不断的使用系统调用来获知IO是否完成
	3.※IO复用:单个进程拥有处理多个IO的能力
	4.信号驱动IO:内核在数据到达时向进程发送信号
	5.异步IO:内核完成所有操作之后向应用进程发送信号
	
	※IO多路复用：
		多个IO操作都能在同一个进程并发按顺序完成 复用指的是复用同一个进程
		
		select：轮询方式处理 基于数组实现 大小为1024 监听1024个描述符 三种事件对应读写异常
		poll：  轮询方式处理 基于链表实现 大小没限制 监听多个事件 
		epoll：采用回调方式检测就绪实现 不需要遍历 时间复杂度为O(1)
```

