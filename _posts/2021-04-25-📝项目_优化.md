## 一.校园视频社区交友平台💕

### 1️⃣. 项目采用主流的Springboot+Vue框架快速开发 ⚡

### 2️⃣. 对慢SQL进行数据库字段和SQL语句的优化 使得查询效率和网站访问速度提高30% 🚀

#### -如何实现?

> #### 1.表字段：int、varchar、time、枚举

> #### 2.SQL语句：减少行列查询量、 

> #### 3.表设计：

> #### 4.主键id自增

> #### 5. 常用字段使用索引

### 3️⃣. 使用WebSocket的长连接全双工通信实现了弹幕功能 优化了采用短连接时空轮询造成的资源浪费问题💦  

#### -如何实现❓

> ###### 1.定义webSocketConfig配置类

```java
@Configuration
public class webSocket {
    @Bean
    public ServerEndpointExporter serverEndpointExporter(){
            return  new ServerEndpointExporter();
    }
}
```

> ###### 2.通过写好的webSocketService类 类中包含一个用户在线人数AtomicInteger和保存在线用户(webSocketService)的ConcurrentHashMap 以及核心的OnMessage()方法发送消息方法 和 链接方法openConnection() [把观看该视频的用户添加至map集合]
 ```java
	@Component
    @ServerEndpoint("/imserver/{token}")
    public class webSocketService {

        private final Logger logger =  LoggerFactory.getLogger(this.getClass());

        public static final AtomicInteger ONLINE_COUNT = new AtomicInteger(0);

        //每个客户端都需要一个webSocketService-因为
        public static final ConcurrentHashMap<String, com.zzw.service.webSocketService> WEBSOCKET_MAP = new ConcurrentHashMap();

        private Session session;

        private String sessionId;

        private Long userId;

        public Session getSession() {
            return session;
        }

        public String getSessionId() {
            return sessionId;
        }

        private static ApplicationContext Application_Context;

        public static void setApplicationContext(ApplicationContext applicationContext){
            com.zzw.service.webSocketService.Application_Context =applicationContext;
        }

        @OnOpen
        public void openConnection(Session session, @PathParam("token") String token){}

        //发送信息方法
        public void sendMessage(String message) throws Exception{}

        @OnClose//断开连接
        public void closeConnection(Session session){}


        @OnMessage//发送信息时候
        public void OnMessage(String message){}

        @OnError//发送错误时候的情况
        public void OnError(Throwable error){}

        //定时任务 - 在主程序中(Blibili_App.class)@EnableScheduling要开启
        @Scheduled(fixedRate = 5000)//fixedRate = 5000毫秒------每隔5s执行一次定时任务

        public void noticeOnlineCount() throws Exception{}


    }
```

> ###### 3.💤当用户发送弹幕时 遍历map集合中的values对象 获得每一webSocketService对象 也就是连接到服务器的用户 然后使用`sentMessage()`方法 进行群发弹幕

> ###### 4.把弹幕字符转出弹幕对象(DanMU) 并且赋值 userId(token获取)、creatTime、videoId

> ###### 5.💤持久化到数据库和Redis

### 4️⃣. 使用RocketMQ和Redis 对发送的弹幕进行削峰和缓存 缓解群发弹幕和数据库的压力 保证系统的稳定性的同时将系统QPS提升了20倍(10/s-200/s) 💥

#### -如何实现❓

> ###### 优化1.RocketMQ对发送的弹幕进行削峰缓解群发压力
>

- ###### 	1.当用户发送弹幕时 遍历map集合中的values对象 获得每一个连接到服务器的用户


- ###### 	2.获取RokctMQConfig配置类中的弹幕生产者


- ###### 	3.构建发送的消息对象`Message`对象 指定消息的主题 以及 发送的消息(`sessionId`和`弹幕内容`)


- ###### 	4.使用定义好的RokctMQUtils方法中的异步发送消息方法发送消息


```java
 //发送方法-异步
    public static  void asyncSendMsg(DefaultMQProducer producer, Message msg) throws Exception {

        //发送2次
        int count = 2;
		
        CountDownLatch2 countDownLatch = new CountDownLatch2(count);

        for(int i=0;i<count;i++){

            //发消息
            producer.send(msg, new SendCallback() {

                @Override
                public void onSuccess(SendResult sendResult) {//成功发送消息
                    countDownLatch.countDown();
                    System.out.println(sendResult.getMsgId());
                }

                @Override
                public void onException(Throwable throwable) {//发送消息-异常
                    countDownLatch.countDown();
                    System.out.println("发送消息-异常:"+throwable);
                }
            });

        }
        countDownLatch.await(5, TimeUnit.SECONDS);
    };
```

- ######  	5.在RokctMQConfig配置类中的生产弹幕消费者的方法中 设置好分组和主题后 在监听器的`consumeMessage()`方法中


- ###### 	6.获取生产者的消息对象


- ###### 	7.把消息对象通过`FastJsonObject`转成弹幕消息和sessionId


- ###### 	8.通过SessionId在Map中找到对应的客户端


- ###### 	9.客户端使用`sentMessage`方法群发弹幕


- ###### 	10.返回消费成功




> ###### 优化2.RocketMQ对发送的弹幕的持久化进行削峰缓解数据库的压力
>

- ###### 	 把弹幕内容转成对应的实体类(DanMu) 并且赋值userId、创建时间


- ######   生产者:

  ###### 		-获取RokctMQConfig配置类中的 对应的消息的生产者

  ###### 		-构建发送的消息对象`Message`对象 指定消息的`主题` 以及 发送的消息-`弹幕对象`

  ###### 		-使用定义好的RokctMQUtils方法中的异步发送消息方法发送消息-削峰使用`countDownLatch`限制发送数据的次数 每次限制发送多少次 做限流 蓄洪和泄洪



- ###### 消费者:

  ###### 	在RokctMQConfig配置类中的生产弹幕消费者的方法中 设置好分组和主题后 在监听器的`consumeMessage()`方法中

  ######     -获取生产者发送消息字符串

  ###### 	-把字符串转成弹幕对象

  ###### 	-把弹幕对象异步持久化到数据库

  ###### 	-消费成功

> ###### 优化3.redis缓存弹幕-缓解数据库请求的压力

- ###### 	-弹幕持久化到数据库后再对Redis进行缓存

  ###### 		-`Key`:`"danmu-"+videoId`

  ######    	-`Value`:`发送的弹幕`

##### 数据和缓存的一系列问题❗

###### 	①数据访问先后:

​		先访问缓存再访问数据库

###### ②缓存和数据库数据一致性的保证

​		缓存有-直接取  缓存没有请求数据库 然后把数据及时用定时任务更新回缓存(先删除key再添加)

​	**缓存雪崩**:key大面积同时失效-----------过期时间设置为随机、热点数据永不过期、

​	**缓存穿透**:对一个根本不存在的数据进行大量请求-比如age=0 缓存找不到 就直接请求数据库 - 对数据库造成巨大压力---------------前端先做校验、布隆过滤器( 将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力 )、设置key null 把不存在的数据任然存在redis 只不过值为null  但它的过期时间会很短，最长不超过五分钟。 

​	

​	**缓存击穿**:大量请求一个以及失效的缓存的key造成数据库宕机-------**加互斥锁**( setnx())( 简单地来说，就是在缓存失效的时候（请求的数据的value为空)  往 redis 用 setnx 设置一个 key，来表示这是一把锁 设置成功后  然后去读取数据库读数据，并且写回 redis  在此期间  其他的线程，则 sleep 一小会，然后再去访问我们的 redis



### 5️⃣. 使用Mahout的协同过滤算法 通过分析用户观看视频的习惯 实现了对相似用户推荐可能喜欢的视频 🔑

#### -如何实现❓

> ###### 1.获取用户偏好数据

###### 		-通过一个用户操作表(id、userId、videoId、operationType) 通过不同的操作类型获取不同的权值 通过sql语句生成 一个新的表 再封装成一个userPreference对象(userId、videoId、value) 的 集合返回

> ###### 2.同过用户偏好数据生成对应数据模型

> ###### 3.计算用户相似度

> ###### 4.计算出相似用户

> ###### 5. 获取推荐器

> ###### 6.生成推荐的视频id

> ###### 7.批量查询视频id获取视频对象集合

> ###### 8.返回视频对象集合

### 6️⃣. 为提高数据的查询响应速度采用ElasticSearch进行优化 QPS从8/s提升至10/s 提升 了约120% 🔥

#### -如何实现❓

> ###### 1.输入关键字 走相关请求

> ###### 2.把再Entity定义的index放入一个数据 放入SearchRequest对象

> ###### 3.生成SearchSource对象

> ###### 4.Query.builder中获取一个mutiMatchQuery对象 输入搜索关键字和Entity定义查询的字段

> ###### 5. SearchSource输入mutiMatchQuery-开始执行查询

> ###### 6.SearchRequest调用Source方法执行SearchSource

> ###### 7.从定义好的restHighLevelClient.search中获取SearchResponse对象

> ###### 8.构建返回结果集合List<Map<String,Object>> list

> ###### 9.遍历SearchResponse.getHits() 把每一个获得的hit转换成map集合 存入list集合

> ###### 10.返回list集合

## 					二.基于人工智能的校园助手💻

### 1️⃣.  独立开发基于Springboot和Vue的长理校园助手，采用主流的前后端分离架构  ⚡

### 2️⃣.  为适应系统特性 加快迭代速度 后端从SSM框架改进至Springboot框架 配合MyBatis框架和Redis缓存实现了数据前后一 体的集中式配置优化 提高了接近1倍的开发效率 🚀

### 3️⃣.  ⭐使用 JWT 生成Access token和 Refresh token 实现双令牌验证机制 完成了登录时用户的身份认证 优化了单令牌情况下 因Token过期造成的潜在安全和用户体验感不佳问题  ❓

#### -如何实现❓

###### 				登录：

> #### 1.登录成功后生成通过JWTUtils生成双token 生成Access token和 Refresh token

> #### 2.把 Refresh token持久化到数据库(先删除再添加)-(id、userId、refreshToken)

> #### 3.返回双令牌-Map (生成的Access token和 Refresh token )

###### 			退出登录：

> #### 1.获取对象头中的 Refresh token 值

> #### 2.删除数据库中对应的Refresh token 值

###### 			刷新Access token时机：

> #### 1.获取对象头中的 Refresh token 值

> #### 2.获取数据库中Refresh token 对应userId

> #### 3.userId没有则token过期异常 有则再通过JWTUtils生成AcessToken

> #### 4.返回AcessToken

##### -优化点❓

> ###### 	1.过期时间太长 退出登录 还可以获取本地的token 去进行操作-安全问题

> ###### 	2.-登录状态AcessToken过期时无感刷新令牌-体验感问题

> ###### 	3.-节省服务器资源-不通过session判断用户信息

### 4️⃣.  ⭐把常用到的热点数据缓存在Redis 利用其于内存的高速读取数据的特性 降低了数据库访问压力  🔑

### 5️⃣.   接入第三方人脸识别SDK 对用户的身份进行验证 进一步保证了用户信息安全并且提升了用户使用体验 🔥

### 6️⃣. ⭐使用RocketMQ实现动态内容的推送💥

> ###### 			1.用户调用相关接口[Post请求] 发送动态时候 生成一个用户动态对象`userMoment` **并且存到数据库中**
>

> ###### 2.通过Application Context上下文的`get bean("userMomentProducter")`方法 获取 动态生产者 

###### 				-这个bean是一个生成生产者的方法  是提前在RocketMQ Configrition 类中定义的 并且注入的  并且生产者提前设置了消息分组

> ###### 3.再定义一个消息对象`(Message)` 并且设置 之前定义主题 和 要推送的内容`(userMoment)`

> ###### 4.最后通过调用 提前写好的RocketMQUtils的发送消息的方法 把定义好的消息 发送到RocketMQ

###### 														-RocketMQUtils类中 包含了一个 同步发送消息方法和一个异步发送消息方法

> ###### 5.再到RocketMQ Configrition 类中的 ***消息消费者***  中消息的监听器中的`consumeMessage`方法中

###### 							-5.1. 获取第一个消息 `MessageExt msg = msgs.get(0);` 

###### 						 								-5.2. 获取到`String userMomentStr = msg.getbody();`

###### 						 								-5.3. 把`userMomentStr` 恢复成 动态对象`userMoment` 

###### 						 								-5.4. 通过`userMoment.getUserId` 获取 发送该动态人的`userId`

###### 						 								-5.5. 通过一个方法获取 这个人的所有粉丝  `List<userFans> list 列表`

###### 						 								-5.6. 通过遍历 粉丝列表 `List<userFans> list`  

###### 																		-获取每一个粉丝的id号 作为 redis 的`key`  

###### 																		-把发送的动态 `userMoment`作为 redis 的`value` 存到 Redis中 

###### 														-5.7. 最后返回消息消费成功信息 `ConsumeConcurrentlyStatus.CONSUME_SUCCESS;`  

> ###### 6.当用户点击动态功能的时候 走一个查询请求 

###### 													 -通过事先定义好的一个support类 验证token 然后获取userId 然后再去 redis中获取 对应的value 即为动态内容

