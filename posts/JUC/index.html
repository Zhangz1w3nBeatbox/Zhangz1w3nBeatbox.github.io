<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.3.3" /><meta property="og:title" content="Juc💎" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="JUC(CAS、Volatile、Synchronized以及锁升级等)" /><meta property="og:description" content="JUC(CAS、Volatile、Synchronized以及锁升级等)" /><link rel="canonical" href="/posts/JUC/" /><meta property="og:url" content="/posts/JUC/" /><meta property="og:site_name" content="zhangz1w3nCode" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-08-26T00:00:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Juc💎" /><meta name="twitter:site" content="@twitter_username" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-08-26T00:00:00+00:00","datePublished":"2022-08-26T00:00:00+00:00","description":"JUC(CAS、Volatile、Synchronized以及锁升级等)","headline":"Juc💎","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/JUC/"},"url":"/posts/JUC/"}</script><title>Juc💎 | zhangz1w3nCode</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="zhangz1w3nCode"><meta name="application-name" content="zhangz1w3nCode"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/config/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">zhangz1w3nCode</a></div><div class="site-subtitle font-italic">You can do all things!</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/zhangz1w3nCode" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['403592973','qq.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>Juc💎</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Juc💎</h1><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1661472000" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2022/08/26 </em> </span><div class="d-flex justify-content-between"> <span> 作者 <em> <a href="https://twitter.com/username">zhangz1w3nCode</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="6101 字"> <em>33 分钟</em>阅读</span></div></div></div><div class="post-content"><h3 id="juccasvolatilesynchronized以及锁升级等"><span class="mr-2"><code class="language-plaintext highlighter-rouge">JUC(CAS、Volatile、Synchronized以及锁升级等)</code></span><a href="#juccasvolatilesynchronized以及锁升级等" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="参考书籍java并发编程的艺术"><span class="mr-2">参考书籍📚:<strong>《Java并发编程的艺术》</strong></span><a href="#参考书籍java并发编程的艺术" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h4 id="一cas"><span class="mr-2">一.<strong>CAS</strong></span><a href="#一cas" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="1概述"><span class="mr-2"><code class="language-plaintext highlighter-rouge">1.概述</code></span><a href="#1概述" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>​ CAS全称(Compare And Swap) 是一种不使用锁而去实现锁功能的算法 也叫乐观锁、自旋锁</p><h5 id="2为什么出现"><span class="mr-2"><code class="language-plaintext highlighter-rouge">2.为什么出现</code></span><a href="#2为什么出现" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>​ 常规使用锁会带来上下文的切换 最终导致用户态到内核态的切换 (多执行一次cpu的切换) 加锁释放锁 死锁 影响执行速度</p><h5 id="3具体实现的算法"><span class="mr-2"><code class="language-plaintext highlighter-rouge">3.具体实现的算法</code></span><a href="#3具体实现的算法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>​ 当从内存中读取一个数据出来 比如说 a=1 ​ 线程k把变量修改成2 —-&gt; a=2 ​ 在把a=2写回内存的期间 去查看原来的a有没有被修改过 ​ 没有则说明 当前k线程操作期间没有其他线程动过 -&gt;修改成功✅ ​ 如果有说明 当前k线程操作期间被其他线程动过 -&gt;修改失败❌</p><h5 id="4优缺点"><span class="mr-2"><code class="language-plaintext highlighter-rouge">4.优缺点</code></span><a href="#4优缺点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>·优点：cas实现了无锁并发 实现了无锁情况下 原子性的修改变量值 减少上下文切换 ·缺点：cas自旋时间过长会一直占用cpu资源 并且吞吐量低 🕘 只能保证一个变量的原子性 如果要保证多个那么需要用锁🔒 ABA问题:如果在检查之前把修改过的值及时改回来 线程就检测不到 当前变量被别人使用过 -解决?-加版本号 每次使用或者更新变量之前更新版本号-AtomicStampedReference</p><h5 id="5底层原理"><span class="mr-2"><code class="language-plaintext highlighter-rouge">5.底层原理</code></span><a href="#5底层原理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>​ 次级实现：Unsafe类中的<code class="language-plaintext highlighter-rouge">compareAndSet()</code> 方法：是一个本地方法 是硬件级别的方法 ​ 最终实现：<code class="language-plaintext highlighter-rouge">lock cmpxchg</code></p><h4 id="二volatile"><span class="mr-2">二.<strong>Volatile</strong></span><a href="#二volatile" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>​</p><h5 id="1概述-1"><span class="mr-2"><code class="language-plaintext highlighter-rouge">1.概述</code></span><a href="#1概述-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>​ Volatile是轻量级的Sychronized 除了原子性 其余的特性都有</p><h5 id="2作用"><span class="mr-2"><code class="language-plaintext highlighter-rouge">2.作用</code></span><a href="#2作用" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>​ 保证线程的单一指令的原子性、可见性、有序性 ​ ​ <code class="language-plaintext highlighter-rouge">可见性</code>: ​ 定义：保证在多线程的情况下 使用的变量值永远是最新的 ​ 原理：==lock前缀指令== (lock addl $0x0,(%esp)) 保证变量被修改的时候及时推送回主存 然后当其他线程的缓存行有它时 致缓存行无效 ​ 实现： ​ 当volatile变量被修改的时候 会通过总线把修改后的数据写回主存 写回主存时 通过缓存一致性协议把它的缓存行锁定 保证修改的原子性 ​ 其他线程在总线通过cpu的嗅探技术 嗅探到自己线程的数据的地址发生变化 那么就致缓存行无效 当下一次使用到该变量时候再去主存中获取 <code class="language-plaintext highlighter-rouge">有序性</code>: ​ 定义：为了提高程序执行的性能 编译器和处理器会对指令进行重新排序 ​ 分类： ​ 编译器：单线程情况下不影响 语义的情况下 可以重新排序——JMM会禁止重排特定类型的编译器 ​ 处理器：如果不存在数据依赖则可以重新排序——JMM要求Java编译器在编译期间生成指令序列时 插入<code class="language-plaintext highlighter-rouge">内存屏障</code>来禁止指令重排 ​ 内存屏障: ​ Load-Load :读-读:A Load-Load B:A读完才能B读 ​ Load-Store :读-写:A Load-Store B:A读完才能B写 ​ Store-Store:写-写:A Store-Store B:A写完才能B写 ​ Store-Load :写-读:A Store-Load B:A写完才能B读</p><p>​ 原则： ​ <code class="language-plaintext highlighter-rouge">happens-before</code>:定义一些规则来禁止一些指令的重排序(改变结果的重排) 根据其规则提供的内存可见性保障来编程 ​ 只要不改变程序的执行结果(单线程程序和正确多线程程序) 编译器和处理器怎么优化都可以</p><p>​ <code class="language-plaintext highlighter-rouge">as-if-serail</code>:保证单线程内程序的执行结果不被改变,单线程程序执行代码时像是串行执行 ​ happens-before:正确同步的多线程程序执行结果不改变,同步正确的多线程程序执行代码时像是串行执行 ​ ​ 规定： ​ ·一个线程的所有操作 happens-before该线程的任意后续操作 ​ ·对一个锁的解锁happens-before对这个锁的加锁 ​ ==·对volatile变量的写happens-before 任意后续对这个volatile变量的读== ​ ·如果A happens-before B, B happens-before C, 那么 A happens-before C ​ ·启动线程时：ThreadA.start() 操作 happens-before 线程 A的任意操作 ​ · 在线程A中执行TheadB.join() 并且成功返回 那么 线程B的任意操作 happens-before 线程A从ThreadB.join()操作成功返回 ​ <code class="language-plaintext highlighter-rouge">原子性</code>: 弱原子性 ​ 通过happed-before原则的结论可知道 volatie的读 总能 得到 最新的 volatitle的写 只要是voaltile变量 除了i++这一类的 都能保证原子性 ​ 实现原理：通过在编译器生成字节码的时候 插入内存屏障来实现 ​ volatile写： ​ 之前：Store-Store ​ 之后：Store-Load ​ volatile读： ​ 之前：Load-Load ​ 之后：Load-Store ​ 为什么不能保证多指令的原子性？ ​ 修改volatile变量分为四步： 1）读取volatile变量到local ​ 2）修改变量值 ​ 3）local值写回 ​ 4）插入内存屏障，即lock指令 ​ 显然前三步都是不安全的，取值和写回之间，不能保证没有其他线程修改</p><h5 id="3应用"><span class="mr-2"><code class="language-plaintext highlighter-rouge">3.应用</code></span><a href="#3应用" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>单例模式下的Double Cheack Lock</p><p>​ 1.出现原因：单例模式下会出现下线程安全的问题 ​ new 一个对象时: ​ 1.分配内存空间 赋默认值 ​ 2.调用构造方法 赋初始值 ​ 3.栈中的引用对象 指向 堆中的实例对象的地址 ​ 其中2和3这两个步骤在多线程的情况下可能发生重新排序 导致拿到一个未正确初始化的对象而执行完毕 ​ 2.解决：使用volatile 关键字 在编译时候 加入Load Store屏障和 Store -Load 屏障 表示 只有当前这个线程写完才能读 防止指令的重排序 ​ 3.代码:</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">singleton</span><span class="o">{</span>
   <span class="kd">private</span> <span class="kd">static</span> <span class="kd">volatile</span> <span class="n">singleton</span> <span class="n">s</span><span class="o">;</span>
   <span class="kd">private</span> <span class="nf">singleton</span><span class="o">(){};</span>
    
   <span class="kd">public</span> <span class="n">singleton</span> <span class="nf">getInstance</span><span class="o">(){</span>
      
       <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">==</span><span class="kc">null</span><span class="o">){</span>
           <span class="n">sychronized</span><span class="o">(</span><span class="k">this</span><span class="o">){</span>
               <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">==</span><span class="kc">null</span><span class="o">){</span>
                   <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="n">singleton</span><span class="o">();</span>
               <span class="o">}</span>
           <span class="o">}</span>
       <span class="o">}</span>
       <span class="k">return</span> <span class="n">s</span><span class="o">;</span>
   <span class="o">}</span>   
 <span class="o">}</span>
</pre></table></code></div></div><p>​ ​</p><h4 id="三synchronized"><span class="mr-2">三.<strong>Synchronized</strong></span><a href="#三synchronized" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="1概述-2"><span class="mr-2"><code class="language-plaintext highlighter-rouge">1.概述</code></span><a href="#1概述-2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>​ 多线程情况下为了保证线程执行安全(线程执行的有序性、可见性、原子性)使用锁去完成 确保同一个时刻最多只有一个线程执行同步代码</p><h5 id="2作用-1"><span class="mr-2"><code class="language-plaintext highlighter-rouge">2.作用</code></span><a href="#2作用-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>​ 保证线程的原子性、可见性、有序性 ​ ​ <code class="language-plaintext highlighter-rouge">可见性</code>: ​ <code class="language-plaintext highlighter-rouge">有序性</code>: ​ <code class="language-plaintext highlighter-rouge">原子性</code>: ​ 内存语意:推送到主存-获取最新值🤩 ​ 释放锁 JMM把线程对应的本地变量刷新到主存——对应于vlatile写——相当于线程向接下来要向获取这个锁的某个线程发信息 ​ 获取锁 JMM把线程对应的本地变量设置为无效 从而使被监视器保护的临界区代码必须从主存读取共享变量——对应于vloatile读——线程B接收了 某个线程发出的的信息</p><h5 id="3使用"><span class="mr-2"><code class="language-plaintext highlighter-rouge">3.使用</code></span><a href="#3使用" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>1.作用在方法：普通方法和静态方法 普通方法：锁的是当前的实例对象 静态方法：锁的是当前类.class对象</p><p>2.作用在同步代码块：锁的括号内的对象</p><p>3.🌟实现原理：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>基于一个Monitor对象去实现的 监视器锁本质又是依赖于底层的操作系统的 Mutex Lock（互斥锁）来实现的
</pre></table></code></div></div><p>​ 任何一个对象都对应一个monitor 当monitor被持有的时候 将会处于锁定状态 线程执行到monitorenter时候 ​ 将尝试获取对象所对应的monitor所有权 即尝试获取对象的锁 如果获取到了监视器 就继续执行下去 直到结束 到了 monitorExit ​ 如果获取不到 则进入同步队列 线程阻塞住 直到获取到监视器的线程退出后发出通知 才能出队列</p><p>​ 同步代码块： ​ 在代码块开始的时候加 monitorenter 结束的时候加monitorexit(一个正常出口一个异常出口) ​ 当线程执行到monitorenter的时候要先获得锁，才能执行后面的方法。 ​ 当线程执行到monitorexit的时候则要释放锁。 ​ 每个对象自身维护着一个被加锁次数的计数器，当计数器不为0时，只有获得锁的线程才能再次获得锁。</p><p>​ 同步方法： ​ 在class文件中 访问标识符被改为<code class="language-plaintext highlighter-rouge">ACC_SYCHRONIZED</code> 当线程要执行的方法被标注上<code class="language-plaintext highlighter-rouge">ACC_SYNCHRONIZED</code>时，需要先获得锁才能执行该方法</p><h5 id="4通信"><span class="mr-2"><code class="language-plaintext highlighter-rouge">4.通信</code></span><a href="#4通信" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>​ 概述：线程的通信通过一个对象Object调用器其Object父类的wait()-notify()/notifyAll()进行通信(wait方法释放锁、notify方法:通知一个在对象上等待的线程 使其从wait方法返回 返回的前提是线程获取到了对象的锁) ​ 细节：使用wait 、notify之前必须要对对象加锁-就是说对象以及获取到锁了-言下之意就是已经持有这个对象了 ​ wait方法调用后 必须释放当前锁 为什么？-因为要避免死锁(请求保持条件)</p><p>​ 具体流程：线程的通信建立在线程的同步之上 因为需要等待线程在等待方法返回时 能感知到通知线程对变量做出的修改-&gt;锁的内存语义 ​ 1.当线程进入monitorenter 就尝试获取对象的monitor ​ 如果获取到了就 获取到对象的所有权 ​ 获取到对象所有权后 调用对象的wait()方法 就会进入等待队列 同时 释放持有的monitor对象 ​ 与此同时 另外一个线程B 进入monitorEnter 尝试获取monitor对象 刚好获取到 然后调用notify方法 把等待队列中的对象 移动到同步队列 然后线程B 正常退出 释放锁了 然后在同步队列的线程A 获取到了锁 就从wait返回继续执行</p><p>​ 如果获取不到就 进入同步队列 等待获取对象执行到monitorexit的通知</p><h5 id="6锁升级"><span class="mr-2"><code class="language-plaintext highlighter-rouge">6.锁升级</code></span><a href="#6锁升级" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>1.锁升级原因： Synchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的，监视器锁本质又是依赖于底层的操作系统的 Mutex Lock（互斥锁）来实现的。而操作系统实现线程之间的切换需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么 Synchronized 效率低的原因。因此，这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为 “重量级锁”。 JDK1.6的优化-引入锁升级 为了减少锁的释放和创建所带来的开销 减少用户态到内核态之间的切换所带来的开销 所以引入锁升级</p><p>2.前置知识: 对象的结构(16字节) ·对象头： ·MarkWord(32位=4字节): 无锁: Hashcode(25位) 分代年龄(4位)、偏向标记位(1位)[0]、锁标记位(2位)[01] 偏向锁: <code class="language-plaintext highlighter-rouge">线程ID(23位)</code>、Epoch(2位)、分代年龄(4位)、偏向标记位(1位)[1]、锁标记位(2位)[01] 轻量级锁: <code class="language-plaintext highlighter-rouge">30位指向栈中锁记录的指针</code> 锁标记位(2位)[00] 重量级锁: <code class="language-plaintext highlighter-rouge">30位指向重量级锁的指针</code> 锁标记位(2位)[10]</p><p>​ ·Class Point:(4字节)虚拟机通过这个指针来确定这个对象是哪个类的实例 ​ 对应jvm类加载的第一步的第三小步”在内存中生成代表该类的.Class对象 程序可以通过这个对象 在方法区访问其的入口“ ​ ·(数组对象:) ·实例数据:((4字节)[不开启指针压缩]/(8字节)) ·填充:(4字节)[开启指针压缩]/(0字节)</p><p>3.锁升级过程 无锁: 没有加锁的对象 偏向锁: 定义:当某个线程一次获得锁时 并且没有线程和其争抢时 偏向于第一次获得锁的那个线程 原因:Hotspot作者发现 大部分情况下锁不仅不存在竞争而且总是被同一个锁多次获取 为了让线程获得的锁代价更低 引入了偏向锁 流程: 添加偏向锁: 当线程进入同步代码块获取到锁后 会在对象头和栈帧中的锁记录里面存储获得到的线程ID 以后该线程在进入和退出同步代码块时 不需要 进行cas的加锁和解锁 只要简单的测试一下对象头中的MarkWord中偏向锁的线程ID是否 是当前线程ID 如果成功则该线程获得锁 如果不是则 查看MarkWord中偏向锁的偏向锁位置是否为1 为1 尝试用CAS把MarkWord的线程Id改成当前当前线程ID 如果不为1 则说明还不是偏向锁 则使用CAS加锁 比较点:是否为当前线程 是否设置了偏向锁标记位</p><p>​ 撤销偏向锁: ​ 当锁出现线程竞争的时候 需要进行锁升级 升级成轻量级锁 要把偏向锁撤销 ​ 偏向锁的撤销需要等到全局的安全点-这个时间点没有正在执行的字节码 ​ 首先会把拥有偏向锁的线程暂停 然后查看持有偏向锁的线程是否活跃 ​ 如果不活跃则 对象头设置为无锁状态 如果活跃拥有偏向锁的栈会被执行 便利对象的锁记录 ​ 栈中的锁记录和MarkWord要么偏向于其他线程 要么就恢复到无锁或者标记为对象不适合作为偏向锁 ​ 最后唤醒暂停的线程</p><p>​ 偏向锁的暂停: ​ 偏向锁默认启动 但是会延迟几秒钟 如果明知一定有线程竞争 可以关闭偏向锁 直接进入 轻量级锁</p><p>​ 轻量级锁: ​ 定义：也叫做自旋锁 当锁有轻量的线程竞争的时候 锁状态升级为轻量级锁 ​ 加锁：在进入同步代码块前 会在当前线程的栈帧中生产一个锁记录对象然后把对象头的markword信息复制到锁记录 ​ 然后线程将尝试用把CAS把markword的前30位的指针 指向 这个锁记录 ​ 解锁：用CAS把栈帧中的MarkWord去替换回到对象头 如果替换不成功则说明 存在锁竞争 就升级成重量级锁 ​ 重量级锁: ​ JDK1.6-自旋超过10次，升级为轻量级锁 如果线程数量过多 超过 cpu核数的一半 消耗CPU过大 不如升级成重量级锁进入等待队列 ​ 处于重量级锁状态下 没获取到锁的线程 会被阻塞 进入阻塞队列 线程挂起 不占用cpu资源</p><p>​ ·重量级锁的原理：JVM中每个对象都会有一个’监视器’，监视器和对象一起创建、销毁。监视器相当于一个用来监视这些线程进入的特殊房间，其义务 是保证（同一时间）只有一个线程可以访问被保护的临界区代码块 ​ ·Hotspot虚拟机中，监视器是由C++类ObjectMonitor实现的 ​ 组成：Cxq：竞争队列(Contention Queue),所有请求锁的线程首先被放在这个竞争队列中 ​ EntryList：Cxq中那些有资格成为候选资源的线程被移动到EntryList中 ​ WaitSet：某个拥有ObjectMonitor的线程在调用Object.wait()方法之后将被阻塞，然后该线程将被放置在WaitSet链表中获得到minitor的对象会 进入owner ​ ·重量级锁会发生线程的上下文切换，从用户态切换到内核态。系统调用是内核态为用户态进程提供的Linux内核态下互斥锁的访问机制，系统调用就会 从用户态切换到内核态，这种切换是需要消耗很多时间的，而JVM重量级锁使用了Linux内核态下的互斥锁mutex。</p><p>各种锁的比较 偏向锁： 适合只有一个线程访问同步代码块 加锁解锁不要耗费资源 但是 如果存在多个线程的锁竞争则会带开 偏向锁撤销的消耗</p><p>​ 轻量级锁： 适合追求响应比的场景 同步代码块执行速度很快 线程不会阻塞 但是 如果始终得不到锁竞争的线程 则会空耗cpu资源</p><p>​ 重量级锁： 适合吞吐量高的场景 同步代码块时间长 线程之间竞争不自选 而是挂起 不耗费资源 但是 线程会阻塞 等待时间长 响应比低</p><h4 id="四aqs"><span class="mr-2">四.<strong>AQS</strong></span><a href="#四aqs" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="定义"><span class="mr-2">定义:</span><a href="#定义" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>​ AbstractQueueSynchronized 抽象队列同步器 是构建锁和其他同步组件的基础框架 采用模版方法模式</p><h5 id="组成"><span class="mr-2">组成:</span><a href="#组成" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>​ 由一个volatile修饰的==state==(表示资源)和 一个 ==双端双向同步队列==(占有资源的在队头 没有获取到的在队尾)组成</p><h5 id="实现"><span class="mr-2">实现:</span><a href="#实现" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>​ 当线程修改state值时 尝试用修改state的值 成功构建成一个结点插入队头 因为只有一个线程去成功获取到同步状态 所以不要cas保证 ​ 不成功 则 把当前线程和等待状态信息 构建结点 用CAS的方式插入队尾 并且阻塞结点的线程 ​ 当线程使用完资源后 释放资源 发出通知 后续结点又可以通过cas修改state值</p><h5 id="方法"><span class="mr-2">方法:</span><a href="#方法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>​ ==AQS可重写的方法:== ​ tryAcquire() 独占式获取同步状态/获取锁 如果符合预期则用cas修改 ​ tryRelease() 独占式释放同步状态/获取锁 如果符合预期则用cas修改 ​ tryAcquireShared() 共享式获取同步状态/获取锁 如果符合预期则用cas修改 ​ tryReleaseShared() 共享式释放同步状态/获取锁 如果符合预期则用cas修改</p><p>​ ==AQS的模版方法:== ​ acquire() 独占式获取同步状态/获取锁 如果成功则返回 不成功加入同步队列等待 该方法重写tryAcquire()方法 ​ acquireInterruptibly() 独占式获取同步状态/获取锁 和acquire()相同只是方法会响应中断 ​ tryAcquireNanos() 在acquireInterruptibly()基础上加了超时限制 如果在一个时间限制内没有获取到锁则返回false</p><p>​ acquireShared() 共享式获取同步状态/获取锁 如果成功则返回 不成功加入同步队列等待 该方法重写tryAcquire()方法 ​ acquireSharedInterruptibly() 共享式获取同步状态/获取锁 和acquire()相同只是方法会响应中断 ​ tryAcquireSharedNanos() 在acquireInterruptibly()基础上加了超时限制 如果在一个时间限制内没有获取到锁则返回false ​ ​ release()独占式释放锁 ​ releaseShared()共享式释放锁</p><h4 id="五各种锁的对比"><span class="mr-2">五.<strong>各种锁的对比</strong></span><a href="#五各种锁的对比" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="cas和synchronized的区别"><span class="mr-2">CAS和Synchronized的区别</span><a href="#cas和synchronized的区别" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>1.加锁的开销：死锁 加锁 解锁 线程切换 内核态到用户态的切换 线程阻塞等待时间长–追求吞吐量 2.CAS的空循环占cpu资源 线程不会阻塞 –追求相应比</p><h5 id="volatile和syncronized区别"><span class="mr-2">Volatile和Syncronized区别</span><a href="#volatile和syncronized区别" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>1.volatile是弱原子性、只能保证单一指令的原子性 而Snchronized不是 保证复合指令的原子性 2.作用对象：volatile作用在变量 范围单一 而 Synchronized 可以作用在代码块和方法上 可以作用在多个变量 3.底层实现：volatile是依靠lock addl 而Synchronized依靠 lock cmpexchge 4.是否阻塞对象：volatile不会阻塞对象 而Synronized对于那些没有拿到锁的对象会阻塞进入同步队列 5.编译器优化：volatile修饰的变量保证不会被编译器优化(除了那些不改变结果的编译器优化) synchronized 修饰的代码块会被编译器优化</p><h5 id="lock和syncronized区别"><span class="mr-2">Lock和Syncronized区别</span><a href="#lock和syncronized区别" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>1.Lock是接口而Syncronized是关键字 2.Lock显式加锁而Syncronized隐式加锁 3.Lock拓展了很多Synchronized的功能: 1&gt;.可中断加锁 2&gt;.可超时加锁 3&gt;.非阻塞加锁 4.Lock作用在代码块而Synchronized作用在代码块和方法 5.底层原理： 1&gt;.Lock是AQS去实现：CAS➕Volatile ——&gt; Lock CMPEXCHG➕Lock指令 AQS：抽象队列同步器是构建锁和其他同步组件的基础框架 组成： 由一个volatile修饰的state(表示资源)和 一个 双端双向队列(占有资源的在队头 没有获取到的在队尾)组成 当线程修改state值时 尝试用cas修改state的值 成功构建成一个结点插入队头 不成功 则构建结点用CAS的方式插入队尾 当线程使用完资源后 释放资源 发出通知 后续结点又可以通过cas修改state值</p><p>​ 2&gt;.Sychronized是通过Monitor去实现：汇编底层是Lock CMPEXCHG指令——&gt;操作系统底层是mutex ​ 底层是c++的monitor实现的：每个对象都有monitor 当进入同步代码块后 首先需要获取monitor对象 如果获取到了就可以进入代码块内 就持有monitor ​ 如果获取不到则进入cxq竞争队列 竞争队列的线程有可能进入同步队列 同步队列的线程 需要等待 持有monitor的线程退出 同步代码块后释放持有的monitor对象才能再次去获取锁 6.Lock有一个同步队列和多个等待队列 而 Sychronized只有一个同步队列和一个等待队列 ​ 在lock中获取完锁后 调用await方法 加入等待队列 此过程不需要cas去保证 因为在此之前 线程一直是持有锁的 通过锁保证没有其他线程去竞争</p><p>7.通信：Lock采用condition机制去通信：await()-signal()/signalAll() 而 Synchronized 采用 wait()和notify()/notifyAll()去实现 8.Lock是可公平可不公平的锁 而Sychronized是不公平锁 公平的含义: 先对锁进行获取的请求先被满足那么就是公平锁 实现原理：在尝试获取锁的时候 需要在AQS的队列中查看当前获取资源的结点是否有前驱结点 有的话就返回不继续执行 没有的话则可以尝试获取资源 作用：公平锁可以防止线程饥饿 但是会频繁的切换线程上下文-用户态到内核态的转换频繁-导致cpu占用高开销大最终导致吞吐量低</p><p>9.Lock加锁后 线程进入等待态 而 Synchronizd 则是进入阻塞态 10.都是可重入锁 重入的概念：线程获取完锁之后还能对资源进行反复的获取锁 实现： 1.验证是否是同一个线程获取锁 2.如果是成功获取锁 则需要对内部一个计数器进行自增 执行完后释放锁需要对其进行自减 当为0的时候 表示最终成功释放</p></div><div class="post-tail-wrapper text-muted"><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Juc%F0%9F%92%8E%20-%20zhangz1w3nCode&url=%2Fposts%2FJUC%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Juc%F0%9F%92%8E%20-%20zhangz1w3nCode&u=%2Fposts%2FJUC%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2FJUC%2F&text=Juc%F0%9F%92%8E%20-%20zhangz1w3nCode" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/%E6%A0%B9%E5%A0%86/">堆</a><li><a href="/posts/Spring/">Spring</a><li><a href="/posts/%E7%AE%97%E6%B3%95-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/">📐算法 滑动窗口</a><li><a href="/posts/%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF/">📐算法 回溯</a><li><a href="/posts/%E7%AE%97%E6%B3%95-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/">📐算法 深度优先遍历</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E5%8D%95%E8%B0%83%E6%A0%88/">单调栈</a> <a class="post-tag" href="/tags/%E5%8E%9F%E5%9C%B0%E5%93%88%E5%B8%8C/">原地哈希</a> <a class="post-tag" href="/tags/%E5%9B%9E%E6%BA%AF/">回溯</a> <a class="post-tag" href="/tags/%E5%A0%86/">堆</a> <a class="post-tag" href="/tags/%E5%A4%9A%E6%8C%87%E9%92%88/">多指针</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/%E6%A0%B9%E5%A0%86/"><div class="card-body"> <em class="small" data-ts="1696646040" data-df="YYYY/MM/DD" > 2023/10/07 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>堆</h3><div class="text-muted small"><p> 堆 🟧概述 🔻含义： 堆是通过数组化二叉树 同时通过构建堆和重建堆 来实现获取最大值和最小值的数据结构 🔻试用场景： 查找最大值和最小值、排序、频率、topK问题 🔻时间复杂度： O(nlogN) 🔻空间复杂度： O(1) 🔻注意事项： 🔸是使用大根堆还是小根堆 🟧模板 📌优先队列 1 2 3 4 5 6 7 8 9 class Solution { pu...</p></div></div></a></div><div class="card"> <a href="/posts/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"><div class="card-body"> <em class="small" data-ts="1696646040" data-df="YYYY/MM/DD" > 2023/10/07 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>滑动窗口</h3><div class="text-muted small"><p> 滑动窗口 🟧概述 🔻含义： 使用一个零时变量记录过程值 当这个过程值满足题目要求时候 就收敛窗口直到过程值不满足题目要求 否则一直扩大窗口统计值 🔻试用场景： 查找连续正数数组或字符串以及子数组、子串问题 🔻时间复杂度： O(n²)-&amp;gt;O(n) 🔻空间复杂度： O(n) 🔻注意事项： 🔸满足滑动窗口的单调性 🔸过程变量的选择(数组、普通变量、容器) 收敛扩大窗口的时机(...</p></div></div></a></div><div class="card"> <a href="/posts/%E5%9B%9E%E6%BA%AF/"><div class="card-body"> <em class="small" data-ts="1696646040" data-df="YYYY/MM/DD" > 2023/10/07 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>回溯</h3><div class="text-muted small"><p> 回溯 🟧概述 🔻含义： 回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就 回溯 返回，尝试别的路径 🔻试用场景： 排列组合、优化穷举等 🔻时间复杂度： 具体问题具体分析 🔻空间复杂度： 递归枚举需要用到栈 🔻注意事项： 🔸单个path回溯完毕后要删除上一次回溯的节点:path.remove(path.size()-1);...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/JVM-%EF%B8%8F/" class="btn btn-outline-primary" prompt="上一篇"><p>Jvm⚙️</p></a> <a href="/posts/MySQL/" class="btn btn-outline-primary" prompt="下一篇"><p>Mysql🔢</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E5%8D%95%E8%B0%83%E6%A0%88/">单调栈</a> <a class="post-tag" href="/tags/%E5%8E%9F%E5%9C%B0%E5%93%88%E5%B8%8C/">原地哈希</a> <a class="post-tag" href="/tags/%E5%9B%9E%E6%BA%AF/">回溯</a> <a class="post-tag" href="/tags/%E5%A0%86/">堆</a> <a class="post-tag" href="/tags/%E5%A4%9A%E6%8C%87%E9%92%88/">多指针</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://twitter.com/username">zhangz1w3nCode</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0">本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></div></footer><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script>
