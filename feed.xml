<feed xmlns="http://www.w3.org/2005/Atom"> <id>/</id><title>zhangz1w3nCode</title><subtitle></subtitle> <updated>2024-04-09T02:31:41+00:00</updated> <author> <name>zhangz1w3nCode</name> <uri>/</uri> </author><link rel="self" type="application/atom+xml" href="/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="/"/> <generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator> <rights> © 2024 zhangz1w3nCode </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>堆</title><link href="/posts/%E6%A0%B9%E5%A0%86/" rel="alternate" type="text/html" title="堆" /><published>2023-10-07T02:34:00+00:00</published> <updated>2024-04-09T02:31:04+00:00</updated> <id>/posts/%E6%A0%B9%E5%A0%86/</id> <content src="/posts/%E6%A0%B9%E5%A0%86/" /> <author> <name>zhangz1w3nCode</name> </author> <category term="算法" /> <summary> 堆 🟧概述 🔻含义： 堆是通过数组化二叉树 同时通过构建堆和重建堆 来实现获取最大值和最小值的数据结构 🔻试用场景： 查找最大值和最小值、排序、频率、topK问题 🔻时间复杂度： O(nlogN) 🔻空间复杂度： O(1) 🔻注意事项： 🔸是使用大根堆还是小根堆 🟧模板 📌优先队列 class Solution { public int heap(int[] nums) { //默认小根堆 PriorityQueue&amp;lt;Integer&amp;gt; minHeap =new PriorityQueue&amp;lt;&amp;gt;((a,b)-&amp;gt;(int)(a-b)); //大根堆 PriorityQueue&amp;lt;Integer&amp;gt; maxHeap =new PriorityQueue&amp;lt;&amp;gt;(... </summary> </entry> <entry><title>滑动窗口</title><link href="/posts/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" rel="alternate" type="text/html" title="滑动窗口" /><published>2023-10-07T02:34:00+00:00</published> <updated>2023-10-07T02:34:00+00:00</updated> <id>/posts/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</id> <content src="/posts/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" /> <author> <name>zhangz1w3nCode</name> </author> <category term="算法" /> <summary> 滑动窗口 🟧概述 🔻含义： 使用一个零时变量记录过程值 当这个过程值满足题目要求时候 就收敛窗口直到过程值不满足题目要求 否则一直扩大窗口统计值 🔻试用场景： 查找连续正数数组或字符串以及子数组、子串问题 🔻时间复杂度： O(n²)-&amp;gt;O(n) 🔻空间复杂度： O(n) 🔻注意事项： 🔸满足滑动窗口的单调性 🔸过程变量的选择(数组、普通变量、容器) 收敛扩大窗口的时机(题意) 🔸收敛窗口的移动(++l) 🔸收敛窗口的条件(LIMIT) 🔸答案是最大值还是最小值(题意) 🔸统计答案的位置(个数还是长度) 🟧模板 📌通用模板 class Solution { public int Window(int[] nums) { int limit=???; int len = nums.length; ... </summary> </entry> <entry><title>回溯</title><link href="/posts/%E5%9B%9E%E6%BA%AF/" rel="alternate" type="text/html" title="回溯" /><published>2023-10-07T02:34:00+00:00</published> <updated>2023-10-07T02:34:00+00:00</updated> <id>/posts/%E5%9B%9E%E6%BA%AF/</id> <content src="/posts/%E5%9B%9E%E6%BA%AF/" /> <author> <name>zhangz1w3nCode</name> </author> <category term="算法" /> <summary> 回溯 🟧概述 🔻含义： 回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就 回溯 返回，尝试别的路径 🔻试用场景： 排列组合、优化穷举等 🔻时间复杂度： 具体问题具体分析 🔻空间复杂度： 递归枚举需要用到栈 🔻注意事项： 🔸单个path回溯完毕后要删除上一次回溯的节点:path.remove(path.size()-1); 🔸结果集收集的条件:if(终止条件) res.add(new ArrayList(path)); 🔸去重的条件:if(去重条件) continue; 🔸每个组合中的值用是否能重复使用 -&amp;gt; 下一次回溯的起点idx 🔸去重的条件和方式 🔸每个组合中的值用是否能重复使用：不能重复用:handle(s,i+1);能重复:handle(s,i); 🔸解集不能包含重复的组合：Array... </summary> </entry> <entry><title>原地哈希</title><link href="/posts/%E5%8E%9F%E5%9C%B0%E5%93%88%E5%B8%8C/" rel="alternate" type="text/html" title="原地哈希" /><published>2023-10-07T02:34:00+00:00</published> <updated>2023-10-07T06:11:54+00:00</updated> <id>/posts/%E5%8E%9F%E5%9C%B0%E5%93%88%E5%B8%8C/</id> <content src="/posts/%E5%8E%9F%E5%9C%B0%E5%93%88%E5%B8%8C/" /> <author> <name>zhangz1w3nCode</name> </author> <category term="算法" /> <summary> 原地哈希 🟧概述 🔻含义： 数组当作哈希表 通过不同场景(重复整数、缺少整数)选择标记方式(交换或者标记为负数) 判断某个值/几个值 存不存在 🔻试用场景： 数组的所有数字都是从0开始或者1开始(正数) 并且对空间复杂度要求为O(1) 🔻时间复杂度： O(n) 🔻空间复杂度： O(n) 🔻注意事项： 🔸数字必须为正数 🔸不能破坏单调性 🟧模板 📌通用模板 public class Temple{ public int Solution(int[] nums) { int len = nums.length; for(int i=0;i&amp;lt;len;++i){ int n =Math.abs(nums[i]); int idx = n-1; int ... </summary> </entry> <entry><title>单调栈</title><link href="/posts/%E5%8D%95%E8%B0%83%E6%A0%88/" rel="alternate" type="text/html" title="单调栈" /><published>2023-10-07T02:34:00+00:00</published> <updated>2023-10-07T06:11:54+00:00</updated> <id>/posts/%E5%8D%95%E8%B0%83%E6%A0%88/</id> <content src="/posts/%E5%8D%95%E8%B0%83%E6%A0%88/" /> <author> <name>zhangz1w3nCode</name> </author> <category term="算法" /> <summary> 单调栈 🟧概述 🔻含义：栈底到栈顶维持一个单调有序的栈 单调栈就是栈里的数据递增或递减存放，也就是要做到有序，如果待入栈数据不符合栈里数据的有序性，则栈顶出栈，一直到栈里数据有序，最后将当前遍历到的元素栈插入到栈顶。 我们将当前还没得到答案的下标暂存于栈内，从而实现「被动」更新答案。也就是说，栈内存放的永远是还没更新答案的下标。 每次将当前遍历到的下标存入栈内，将当前下标存入栈内前，检查一下当前值是否能够作为栈内位置的答案（即成为栈内位置的「下一个更大的元素」），如果可以，则将栈内下标弹出。 求最近的最大值使用 递减栈 反之最大栈 - &amp;gt;max = Math.max(max,temp);max=Integer.MIN_VALUE; 🔻试用场景： 找最近一个比当前值大或者小的左边和右边的坐标 空间优化时间 🔻时间复杂度： O(n²) -&amp;gt;O(n) 🔻空间复... </summary> </entry> </feed>
